<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统安全（更新中）</title>
      <link href="/2024/10/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
      <url>/2024/10/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（更新中）</title>
      <link href="/2024/10/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
      <url>/2024/10/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><p>本文主要是记录博主学习计网的新路历程。小标题前带*的是等待补充的内容，小标题前带**的是重点内容。</p><h2 id="第一章-概述">第一章 概述</h2><h3 id="计算机网络在信息时代的作用">1.1 计算机网络在信息时代的作用</h3><h3 id="初始计算机网络">1.2 初始计算机网络</h3><p>互联网的发展阶段</p><h3 id="互联网的组成">1.3 互联网的组成</h3><ul><li><p>边缘部分：连接在互联网上的主机组成</p></li><li><p>核心部分：大量网络和路由器组成</p></li><li><p>主机间通信方式：</p><ul><li><em>C/S（Client/Server）</em>：客户程序主动发起请求，服务端始终运行</li><li><em>P2P（Peer toPeer）</em>：仅在初始阶段依赖服务器，是<em>C/S</em>的变种</li></ul></li><li><p>我国的<em>ISP</em>：</p></li><li><p>三种交换技术：</p><ul><li><p>电路交换</p><ul><li>典型：电话网络</li><li>电路交换机接通电话线的方式</li><li>按某种方式<strong>动态</strong>分配传输资源</li><li>三个阶段<ul><li>建立连接（分配资源）</li><li>通信（占用资源）</li><li>释放连接（归还资源）</li></ul></li><li>效率极低</li></ul></li><li><p>分组交换</p><ul><li>发送方：构造分组、发送分组</li><li>路由器：缓存分组、转发分组</li><li>接收方：接受分组、还原报文</li></ul><p>Q：为什么添加首部？A：保证路由器能转发到正确的接收方。</p></li><li><p>报文交换</p><ul><li>对报文大小无限制</li><li>要求路由器有较大的缓存空间</li></ul></li></ul></li></ul><h3 id="计算机网络的分类">1.4 计算机网络的分类</h3><ul><li>根据覆盖范围<ul><li>广域网<em>WAN</em>：互联网的核心部分</li><li>城域网<em>MAN</em>：5-50<em>km</em></li><li>局域网<em>LAN</em>：校园网、企业网、1<em>km</em></li><li>个人局域网<em>PAN</em>：10<em>m</em>之内</li></ul></li><li>根据使用者<ul><li>公用网：面向大众服务的网络</li><li>专用网：军队、铁路、银行等</li></ul></li><li>根据拓扑结构<ul><li>总线型</li><li>星型</li><li>环型</li><li>网状型</li></ul></li></ul><h3 id="计算机网络的性能">1.5 计算机网络的性能</h3><ul><li>速率<ul><li>常用单位：<em>bps</em>，<em>Mbps</em></li></ul></li></ul><p>注意<em>Mbps</em>和<em>MB</em>的区别：1<em>Mbps</em>=<spanclass="math inline">\(10^6\)</span><em>bps</em> 1<em>MB</em>=<spanclass="math inline">\(2^{20}\)</span><em>B</em></p><h3 id="计算机网络的体系结构">1.6 计算机网络的体系结构</h3><p>0.1 <em>OSI</em>体系结构（7层）【法律上的国际标准】：</p><ul><li>物理层</li><li>数据链路层</li><li>网络层</li><li>运输层</li><li>会话层</li><li>表示层</li><li>应用层</li></ul><p>0.2 <em>TCP/IP</em>（4层）【<strong>事实</strong>上的国际标准】：</p><ul><li>网络接口层</li><li>网际层</li><li>运输层</li><li>应用层</li></ul><p><strong>但是</strong>，为了方便教学，通常采用5层结构：</p><ul><li><em>物理层</em></li><li><em>数据链路层</em></li><li><em>网络层</em></li><li><em>运输层</em></li><li><em>应用层</em></li></ul><h4 id="物理层">物理层</h4><p>Q：用什么连接？A：双绞线、光纤、无线。</p><p>Q：用什么接口？A：<em>RJ</em>45网口。</p><p>Q：用什么信号传输？A：电信号、光信号。</p><h4 id="数据链路层">数据链路层</h4><p>Q：物理地址的位数和进制？A：16进制48位，用横杠连接。<em>eg：F0-20-FF-71-4A-EE</em></p><p>Q：如何从比特流中分离出地址</p><p>Q：如何协调主机争用总线？A：共享网络采用<em>CSMA/CD</em>协议，交换网络无需使用协议。</p><h4 id="网络层">网络层</h4><p>Q：如何标识不同的网络及网络中的主机？A：<em>IP</em>地址（网络号+主机号）。<em>eg：192.168.6.5</em></p><p>Q：路由器如何转发分组？如何进行路由选择？A：路由协议。</p><h4 id="运输层">运输层</h4><p>Q：如何解决进程之间基于网络的通信？A：端口号。<em>eg：127.0.0.1:8080</em></p><h4 id="五层pdu">五层<em>PDU</em></h4><ul><li><p><em>物理层：比特<strong>（不参与封装）</strong></em></p></li><li><p><em>数据链路层：帧</em></p></li><li><p><em>网络层：IP包</em></p></li><li><p><em>运输层：报文段</em></p></li><li><p><em>应用层：报文</em></p></li><li><p><strong>举例：</strong></p></li><li><p><strong>专业术语：</strong></p><ul><li>实体：</li><li>对等实体：</li><li>协议：两个对等实体之间的通信规则。</li><li>服务：在协议的控制下，本层向上一层提供服务，本层使用下一层提供的服务。</li></ul></li></ul><h2 id="第二章-物理层">第二章 物理层</h2><h3 id="物理层的基本概念">2.1 物理层的基本概念</h3><h4 id="传输媒体">传输媒体</h4><ul><li>导引型<ul><li>双绞线（4对8根）<ul><li>屏蔽双绞线<em>STP</em></li><li>非屏蔽型双绞线<em>UTP</em><ul><li>T568A：绿白、绿、橙白、蓝、蓝白、橙、棕白、棕</li><li>T568B：橙白、橙、绿白、蓝、蓝白、绿、棕白、棕</li><li>直通双绞线：不同设备、两端都是<em>T568A/B</em></li><li>交叉双绞线：相同设备、一端是<em>T568A</em>，另一端是<em>T568B</em></li></ul></li><li><em>家庭多选Ⅵ类和ⅥA类网线</em></li></ul></li><li>同轴电缆</li><li>光纤<ul><li>包层：<em>125mm</em>，折射率低</li><li>纤芯：<em>8-100mm</em>，折射率高</li><li>多模光纤与单模光纤<ul><li>多模光纤：远距离，光多次反射，光源为发光二极管，接受器为光电二极管</li><li>单模光纤：近距离，光不反射，光源为激光发射器，接收器为激光检测器</li></ul></li></ul></li><li>电力线</li></ul></li><li>非导引型</li></ul><h3 id="传输媒体-1">*2.2 传输媒体</h3><h3 id="数据通信基础">2.3 数据通信基础</h3><h4 id="传输方式">2.3.1 传输方式</h4><ul><li>串、并行<ul><li>串行：远距离，时间慢，成本低</li><li>并行：近距离，时间快，成本高</li></ul></li><li>同、异步<ul><li>同步：数据以连续bit流传输，字节之间无时间间隔</li><li>异步：数据以字节传输，</li></ul></li><li>单工、半双工、全双工</li></ul><h4 id="编码与调制">2.3.2 编码与调制</h4><ul><li><p>数字基带信号</p><ul><li>→数字信道（编码）：</li><li>→模拟信道（调制）：</li></ul></li><li><p>模拟基带信号</p><ul><li>→数字信道（编码）：</li><li>→模拟信道（调制）：</li></ul></li><li><p>码元</p><ul><li>构成信号的一段波形</li></ul></li><li><p>常见编码</p><ul><li>不归零制（时钟累计误差）</li><li>归零制（浪费带宽）</li><li>曼彻斯特编码：相同边界跳变，上下为1，下上为0（以太网）</li><li>差分曼彻斯特编码：不同边界跳变</li></ul></li><li><p>基本调制方法</p><ul><li>调频</li><li>调幅</li><li>调相</li></ul></li><li><p>信道的极限容量</p><ul><li>失真率与<strong>速率、距离、噪声、媒体质量</strong>有关</li></ul></li><li><p>信道的极限传输速率</p><ul><li><p>任何信道中，<strong>码元的传输速率是有上限的</strong>，否则会出现<strong>码间串扰</strong>。</p></li><li><p>理想情况：<strong>奈氏准则</strong>：</p><p><span class="math inline">\(C=2W\)</span> （低信道）</p></li></ul><p><span class="math inline">\(C=W\)</span> （高信道）</p><ul><li><p>实际情况：<strong>香农公式</strong>： <spanclass="math display">\[C=W*log_2(1+S/N)\]</span></p><p>信噪比：<span class="math inline">\(10lg(S/N)\)</span></p></li></ul></li></ul><h3 id="信道复用技术">2.4 信道复用技术</h3><h4 id="频分复用fdm">2.4.1 频分复用<em>FDM</em></h4><ul><li>频率划为等宽<em>FDM</em>帧</li></ul><h4 id="时分复用tdm">2.4.2 时分复用<em>TDM</em></h4><ul><li>时间划为等长<em>TDM</em>帧</li><li>特点：周期性出现</li><li>缺点：信道浪费</li></ul><h4 id="统计时分复用stdm">2.4.3 统计时分复用<em>STDM</em></h4><ul><li>特点：按需动态分配时隙</li></ul><h4 id="波分复用wdm">2.4.4 波分复用<em>WDM</em></h4><p>光的频分复用</p><h4 id="码分复用cdm">2.4.5 码分复用<em>CDM</em></h4><p><strong><em>CDMA</em></strong></p><ul><li><p>广泛应用与2G、3G、<em>WIFI</em>、<em>BlueTooth</em>。</p></li><li><p><em>CMDA</em>通常把自身划分为多个码片，例如64位或128位：</p><ul><li>会先将自身编码进行转换：0--&gt;-1，1--&gt;+1。</li><li>若发送比特0，则发送二进制反码；若发送比特1，则原样输出。</li></ul></li></ul><p><em>【例：】S</em>站的8<em>bit</em>的码片序列为10010001。表示比特1时，发送10010001；表示比特0时，发送01101110。</p><p><em>S</em>站的码片序列为（+1 -1 -1 +1 -1 -1 -1 +1）。</p><ul><li><p>令向量 <strong><em>S</em></strong> 表示站<em>S</em>的码片向量，令 <strong><em>T</em></strong>表示其他任何站的码片向量。</p></li><li><p>两个不同站的码片序列正交，就是向量 <strong><em>S</em></strong>和<strong><em>T</em></strong> 的规格化内积(<em>inner product</em>)都是0： <span class="math display">\[  S·T\equiv\frac1 m \sum_{i=1}^{m} S_i T_i=0  \]</span></p></li><li><p>任何一个码片向量和该码片自己的规格化内积都是1。 <spanclass="math display">\[S·S\equiv\frac1 m \sum_{i=1}^{m} S_i S_i\equiv\frac1 m \sum_{i=1}^{m}S_i^2\equiv\frac1 m \sum_{i=1}^{m} (\pm1)^2=1\]</span></p></li><li><p>任何一个码片向量和该码片反码的规格化内积都是-1。</p></li></ul><p><span class="math display">\[S·S&#39;\equiv\frac1 m \sum_{i=1}^{m} S_i S&#39;_i\equiv\frac1 m\sum_{i=1}^{m} 1* (-1)=-1\]</span></p><h3 id="宽带接入技术">2.5 宽带接入技术</h3><p>接入网络的带宽？共享还是独占？</p><ul><li><em>ADSL</em>（家庭网络）<ul><li>模拟电话网络（电话线改造）</li><li>频分复用</li><li>低频上行，高频下行，上下行带宽不对称</li><li><em>ISP</em>：中国电信（<em>China Telecom</em>）</li></ul></li><li><em>HFC</em>（家庭网络）<ul><li>有线电视网络</li><li>频分复用</li><li>数据和电视节目用不同频率传输</li><li><em>ISP</em>：国家广播电视总局</li></ul></li><li><em>FTTx</em>（企业、公司）<ul><li>光纤入户（光猫 ）</li></ul></li><li><em>LAN</em><ul><li>家庭不需要猫，直接连接上网</li></ul></li></ul><h2 id="数据链路层-1">3.数据链路层</h2><h3 id="链路层概述">3.1 链路层概述</h3><p>链路：从一个节点到相邻节点的一段物理线路。</p><p>数据链路：物理链路+通信协议</p><ul><li>常见的帧<ul><li><em>Wifi</em>：802.11帧</li><li><em>Ethernet</em> <span class="math inline">\(V_Ⅱ\)</span><em>MAC</em>帧（以太网）</li></ul></li><li>三个基本问题<ul><li>封装成帧<ul><li>根据网卡地址寻址</li></ul></li><li>差错检测</li><li>可靠传输<ul><li>帧尾有检测码</li><li><strong>有线</strong>链路误码率<strong>低</strong>，<strong>无线</strong>链路误码率<strong>高</strong></li><li>有线向上层提供不可靠传输，无线必须提供可靠传输</li></ul></li></ul></li><li>两种信道类型<ul><li>点对点信道：<em>PPP</em>帧 （交换式局域网）</li><li>广播信道：<ul><li>交换式局域网：交换机，<em>Ethernet</em> <spanclass="math inline">\(V_Ⅱ\)</span> <em>MAC</em>帧</li><li>共享式局域网<ul><li>总线型有线局域网：<em>Ethernet</em> <spanclass="math inline">\(V_Ⅱ\)</span><em>MAC</em>帧（<em>CSMA/CD</em>协议）</li><li>无限局域网：802.11帧</li></ul></li></ul></li></ul></li><li>帧定界<ul><li><em>PPP</em>帧：定界符01111110</li><li><em>MAC</em>帧：前导码（<em>7B</em>前同步码+<em>1B</em>帧开始符），空隙表示结束</li></ul></li><li>透明传输<ul><li>字节填充法（异步）<ul><li><em>ASCII（&lt;0x20）→7D+0x20</em></li></ul></li><li>零比特填充法（同步）<ul><li>发送端：每11111就添加0</li><li>接收端：每11111后删除0</li></ul></li></ul></li><li><em>MTU</em>（最大传输单元）<ul><li><em>PPP</em>和<em>MAC</em>帧：<em>MTU</em>=1500</li></ul></li></ul><h3 id="差错检测">*3.2 差错检测</h3><ul><li><em>CRC</em>循环校验</li><li>生成多项式</li></ul><h3 id="点对点ppp">*3.3 点对点<em>PPP</em></h3><h3 id="csmacd载波监听多点接入碰撞检测">3.4<em>CSMA/CD</em>（载波监听多点接入/碰撞检测）</h3><ul><li><p>载波监听CS</p><ul><li>发送数据前先检测是否空闲<ul><li>有&gt;96比特空闲：发送</li><li>无：停止</li></ul></li></ul></li><li><p>多点接入MA</p><ul><li>多主机连接在同一根总线上，竞争使用总线</li></ul></li><li><p>碰撞检测CD</p></li><li><p>争用期</p><ul><li>以太网的端到端内往返时间<em>2<spanclass="math inline">\(\tau\)</span></em></li><li><em>10Mb/s</em>以太网的争用期<em>2<spanclass="math inline">\(\tau\)</span>=51.2<spanclass="math inline">\(\mu\)</span>s</em></li><li>最先发送数据的主机在争用期内未检测到碰撞，则这次发送肯定不会发生碰撞</li></ul></li><li><p>截断二进制指数退避算法</p></li></ul><p>退避时间=<em>r</em>倍争用期=<em>r*2</em><spanclass="math inline">\(\tau\)</span></p><h3 id="mac地址">*3.5 <em>MAC</em>地址</h3><h3 id="集线器与交换机的区别">*3.6 集线器与交换机的区别</h3><h3 id="交换机的自学习功能">*3.7 交换机的自学习功能</h3><h3 id="生成树协议stp">*3.8 生成树协议<em>STP</em></h3><ul><li>运行在交换机内</li></ul><h3 id="虚拟局域网vlan">3.9 虚拟局域网<em>VLAN</em></h3><ul><li>以太网规模与广播域</li><li>VLAN的实现机制<ul><li>802.1Q帧</li><li>交换机端口类型<ul><li>ACCESS：连接<strong>主机</strong>，<strong>接收帧</strong>时打标签，若<strong>帧的<em>VLANID</em>=端口的<em>VLAN ID</em>则去标签转发</strong>否则不转发</li><li>TRUNK：连接交换机和路由器，默认属于所有<em>VLAN</em></li></ul></li></ul></li><li>基于端口划分<em>VLAN</em></li></ul><p><strong><em>VLAN</em>技术对于主机是透明的。</strong></p><h3 id="高速以太网">*3.10 高速以太网</h3><h2 id="网络层-1">4.网络层</h2><h3 id="网络层概述">4.1 网络层概述</h3><ul><li>主要任务<ul><li>实现网络互连</li><li>实现数据包在不同网络之间的传输</li></ul></li><li>需要解决的主要问题<ul><li>网络层寻址（<em>IP</em>地址）</li><li>路由选择（路由表）</li><li>向运输层提供可靠/不可靠服务</li></ul></li><li>提供的两种服务<ul><li><strong>可靠</strong>的虚电路服务</li></ul></li></ul><h3 id="ipv4地址">4.2 <em>IPv4</em>地址</h3><ul><li>点分十进制</li><li>32比特</li></ul><p>Q：哪些设备需要配<em>IP</em>？A：主机、路由</p><p>Q：怎样为接口分配<em>IP</em>地址？ A：同网同号，异网异号</p><ul><li><em>IPv4</em>地址结构<ul><li>网络号</li><li>主机号</li></ul></li></ul><p><em>eg：120.0.0.0/8→网络号为120，其余为主机号</em></p><ul><li><p><em>IP</em>地址的分类</p><ul><li><p>A类：0.0.0.0--127.255.255.255</p><ul><li>8+24</li><li>点分十进制以0开头</li></ul></li><li><p>B类：128.0.0.0--191.255.255.255</p><ul><li>16+16</li><li>点分十进制以10开头</li></ul></li><li><p>C类：192.0.0.0--223.255.255.255</p><ul><li>24+8</li><li>点分十进制以110开头</li></ul></li><li><p>D类：224.0.0.0--239.255.255.255</p><ul><li>多播地址</li><li>点分十进制以1110开头</li></ul></li><li><p>E类：240.0.0.0--255.255.255.255</p><ul><li>保留地址</li><li>点分十进制以1111开头</li></ul></li><li><p><strong>注意</strong></p><ul><li><p>仅<strong>A、B、C</strong>三类<strong>可分配</strong>给主机或路由器接口</p></li><li><p>主机号全0或全1<strong>不能分配</strong>给主机或路由器接口</p></li><li><p>网络号非0，主机号全0→网络地址</p></li><li><p>网络号非0，主机号全1→直接广播地址（特定网络中所有主机）</p></li><li><p>网络号、主机号全1→有限广播地址（本网络中所有主机）</p></li><li><p>网络号、主机号全0→未获取<em>IP</em>的主机或路由表的默认路由</p></li><li><p>网络号127、主机号全0或全1除外的任何数→环回地址</p></li><li><p>169.254开头→不能通过<em>DHCP</em>正常获取<em>IP</em>时，<em>Windows</em>自动分配</p></li></ul></li></ul></li></ul><h3 id="划分子网与cidr">4.3 划分子网与<em>CIDR</em></h3><ul><li>划分子网（防止地址浪费）<ul><li><em>IP</em>子网（<em>subnet</em>）<ul><li>网络地址=网络号+子网号</li><li>默认网关：最大段 <em>eg：xxx.xxx.xxx.254</em></li></ul></li></ul></li></ul><p>Q：已知某主机的<em>IP</em>地址是145.13.5.10，其所在网络的网络地址是145.13.0.0吗？</p><p>A：可能是。</p><ul><li><p>子网掩码</p><ul><li>形如<em>IP</em>地址<ul><li>32位</li><li>点分十进制</li><li><em>Net ID</em>、<em>Sub ID</em>全为1</li><li><em>Host ID</em>全为0</li></ul></li></ul></li><li><p>*网络地址计算方法</p><ul><li>IP地址<em>and</em>子网掩码</li></ul></li><li><p>**子网判断</p><ul><li>网络地址=<em>IP</em>地址&amp;子网掩码</li><li>广播地址=网络地址|~子网掩码</li></ul></li><li><p>**无分类编址</p></li><li><p>路由聚合</p><ul><li><p>前提：</p></li><li><p>公共前缀：提取相同部分，其余全0</p></li></ul></li><li><p>最长前缀匹配</p><ul><li>当目的地址与转发表中多个表项匹配，选择最长前缀匹配的表项</li></ul></li></ul><h3 id="地址解析协议arp">4.4 地址解析协议<em>ARP</em></h3><ul><li><em>ARP</em>工作原理（同一<em>LAN</em>）<ul><li><em>ARP</em>请求：<strong>广播</strong>本机<em>IP</em>地址和<em>MAC</em>地址</li><li><em>ARP</em>响应：<strong>单播</strong>本机<em>IP</em>地址和<em>MAC</em>地址</li></ul></li><li><em>ARP</em>工作原理（跨越<em>LAN</em>）<ul><li>已知</li></ul></li><li><em>ARP</em>表项的类型<ul><li>动态：自动获取，2分钟有效</li><li>静态：手动设置，永久有效</li></ul></li></ul><p>Q：ARP可以跨网使用吗？ A：不行。</p><h3 id="ip数据报的发送与接收">4.5 <em>IP</em>数据报的发送与接收</h3><ul><li>发送IP数据报的过程<ul><li>直接交付：同网主机</li><li>间接交付：异网主机</li></ul></li></ul><p>Q：如何判断是否同网？ A：子网判断。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（更新中）</title>
      <link href="/2024/10/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
      <url>/2024/10/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1计算机系统概论"><a class="markdownIt-Anchor" href="#1计算机系统概论"></a> 1.计算机系统概论</h2><h3 id="11计算机系统简介"><a class="markdownIt-Anchor" href="#11计算机系统简介"></a> 1.1计算机系统简介</h3><h4 id="111计算机的软硬件概念"><a class="markdownIt-Anchor" href="#111计算机的软硬件概念"></a> 1.1.1计算机的软硬件概念</h4><ul><li>计算机=硬件+软件<ul><li>软件=应用软件(Application,APP)+系统软件(Operating System,OS)</li></ul></li></ul><h4 id="112计算机系统的层次结构"><a class="markdownIt-Anchor" href="#112计算机系统的层次结构"></a> 1.1.2计算机系统的层次结构</h4><ul><li>五个层级：<ul><li>1.高级语言级</li><li>2.汇编语言级</li><li>3.操作系统级</li><li>4.传统机器级</li><li>5.微程序设计级</li></ul></li><li>三种语言：<ul><li>高级语言（C、Java、Python）</li><li>汇编语言（助记符）</li><li>机器语言（二进制）</li></ul></li><li>两种程序：<ul><li>编译程序（高级语言–汇编语言）</li><li>解释程序（汇编语言–机器语言）</li></ul></li></ul><p><img src="https://s3.bmp.ovh/imgs/2024/10/02/05e7445d3d4dfbf5.png" alt="" /></p><h3 id="12计算机的基本组成"><a class="markdownIt-Anchor" href="#12计算机的基本组成"></a> 1.2计算机的基本组成</h3><h4 id="121冯诺依曼计算机的特点"><a class="markdownIt-Anchor" href="#121冯诺依曼计算机的特点"></a> 1.2.1冯·诺依曼计算机的特点</h4><ul><li>一个核心：<ul><li>运算器</li></ul></li><li>五大部件：<ul><li>输入设备</li><li>运算器</li><li>控制器</li><li>存储器</li><li>输出设备</li></ul></li><li>三大部分<ul><li>I/O设备</li><li>CPU</li><li>存储器</li></ul></li></ul><p><img src="https://s3.bmp.ovh/imgs/2024/10/02/934b1ac4ed3f751d.png" alt="" /><br /><strong>注意：对于现代计算机来说，存储器才是核心。</strong></p><h3 id="13计算机硬件主要的技术指标"><a class="markdownIt-Anchor" href="#13计算机硬件主要的技术指标"></a> 1.3计算机硬件主要的技术指标</h3><h4 id="131机器字长"><a class="markdownIt-Anchor" href="#131机器字长"></a> 1.3.1机器字长</h4><p>CPU一次能处理数据的二进制位数（运算速度和报价）。</p><h4 id="132存储容量"><a class="markdownIt-Anchor" href="#132存储容量"></a> 1.3.2存储容量</h4><p>存放二进制信息的总位数。<br />主存容量=MAR（存储单元个数）*MDR（存储字长）<br />辅存容量</p><h4 id="133运算速度"><a class="markdownIt-Anchor" href="#133运算速度"></a> 1.3.3运算速度</h4><p>主频：CPU内核工作的时钟频率<br />时钟周期：CPU内部两个功能部件之间传递信息的最短时间<br />CPI：CPU执行一条指令所需的时钟周期数<br />IPC：每个时钟周期能执行的指令条数<br />MIPS：每秒能执行的指令总数（百万条/秒）<br /><em>吉普森法：</em></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>T</mi><mi>m</mi></msub><mo>=</mo><msubsup><mi>Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>f</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_m=\varSigma_{i=1}^n f_i *t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord"><span class="mord mathit">Σ</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><h2 id="2计算机的发展与应用"><a class="markdownIt-Anchor" href="#2计算机的发展与应用"></a> 2.计算机的发展与应用</h2><h3 id="21计算机的发展史"><a class="markdownIt-Anchor" href="#21计算机的发展史"></a> 2.1计算机的发展史</h3><p><img src="https://s3.bmp.ovh/imgs/2024/10/02/74d4acb942a70ad8.png" alt="" /><br />计算机的发展历程是基于<em>逻辑元件</em>划分的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> basic knowledge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KPCUP2024-WP</title>
      <link href="/2024/09/23/KPCUP2024-WP/"/>
      <url>/2024/09/23/KPCUP2024-WP/</url>
      
        <content type="html"><![CDATA[<p>太好丸辣！！！</p><h1 id="misc"><a class="markdownIt-Anchor" href="#misc"></a> misc</h1><h2 id="1俺は東京レ"><a class="markdownIt-Anchor" href="#1俺は東京レ"></a> 1.俺は東京レ</h2><h3 id="hint"><a class="markdownIt-Anchor" href="#hint"></a> hint</h3><ul><li>浏览器当然要找找浏览记录</li><li>我们的秘密</li><li>9E 97 BA 2A，这似乎不应该是音频文件中存在的hex部分，反而应该是……</li></ul><p>首先打开附件，发现是一个类似浏览器的文件。<br /><img src="https://s3.bmp.ovh/imgs/2024/09/23/707865dbf57ca8d4.png" alt="" /><br />hint中说找浏览记录。众所周知，浏览记录是一个数据库文件。那就去找一个好用的小东西打开它。（本来想用navicat的，但是出题人偷偷跟我说其它工具就可以打开，那我当然用别的工具啦~）<br /><img src="https://s3.bmp.ovh/imgs/2024/09/23/af84431415d17487.png" alt="" /><br />这里在框中搜索“His”，就可以看到History.db这个文件了。然后我选择用SQLiteSPY打开。<br /><img src="https://s3.bmp.ovh/imgs/2024/09/23/6fd4b56e08b2d0b9.png" alt="" /><br />打开后发现两个关键信息：其一是出题人的B站主页，其二是百度网盘链接。<br />然后出题人的B站签名告诉我们uid就是一个key（原神！启动！），再去下载一下那个小文件。发现是个压缩包，包里面就是这首歌（但是被伪加密过，需要一些力气和手段/doge）。<br /><img src="https://s3.bmp.ovh/imgs/2024/09/23/9bfbe530f934319e.png" alt="" /><br />解压出来后把文件放到010editor里面去，查看文件16进制码。<br /><img src="https://s3.bmp.ovh/imgs/2024/09/23/0661a5dc0dbb7aae.png" alt="" /><br />hint中给出了提示，这9E97BA2A不对劲啊，我想到了文件分离。<br /><img src="https://s3.bmp.ovh/imgs/2024/09/23/96fb397dd005dd16.png" alt="" /><br />必应一查发现是OurSecret隐写，然后找个小工具解一下密（好吧，hint其实讲了，但我不知道什么意思），得到flag.txt。<br /><img src="https://s3.bmp.ovh/imgs/2024/09/23/ff1a7f60d6057f0e.png" alt="" /><br />打开flag.txt，里面就是flag。<br /><img src="https://s3.bmp.ovh/imgs/2024/09/23/6feb871bd1484969.png" alt="" /></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>外网打点步骤</title>
      <link href="/2024/08/23/%E5%A4%96%E7%BD%91%E6%89%93%E7%82%B9%E6%AD%A5%E9%AA%A4/"/>
      <url>/2024/08/23/%E5%A4%96%E7%BD%91%E6%89%93%E7%82%B9%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="1信息收集"><a class="markdownIt-Anchor" href="#1信息收集"></a> 1.信息收集</h2><h3 id="情报数据类型"><a class="markdownIt-Anchor" href="#情报数据类型"></a> 情报数据类型</h3><p>常见的情报数据类型分为以下三种：</p><ul><li><p>web资产</p></li><li><p>IP</p></li><li><p>邮箱</p></li></ul><h3 id="收集方式"><a class="markdownIt-Anchor" href="#收集方式"></a> 收集方式</h3><ul><li><p>web资产</p><ul><li><p>空间测绘平台、威胁情报（Virustotal、QAX、360、微步）</p></li><li><p>企业信息（企查查、天眼查、小蓝书等）</p></li><li><p>证书、github、资产特征、APK反编译、子域名、目录检测</p></li></ul></li><li><p>IP</p><ul><li><p>域名反查</p></li><li><p>空间测绘平台（FOFA、360 Quake、Shodan、钟道之眼、鹰图平台等）</p></li><li><p>IP相关工具（Nmap、Goby、Masscan）</p></li></ul></li><li><p>邮箱</p><ul><li><p>招投标网站、招聘渠道、github、百度文库、网盘搜索</p></li><li><p>搜索引擎</p></li><li><p>目标资产站点 -&gt; 爬取</p></li><li><p>企业信息（企查查、天眼查、小蓝书等）</p></li><li><p>在线查询平台（<a href="http://skymem.info">skymem.info</a>、<a href="http://hunter.io">hunter.io</a>、<a href="http://email-format.com">email-format.com</a>）</p></li></ul></li></ul><p><font color=greee>提示：在外网打点的前期，可以尝试在Wooyun漏洞库里搜索与“靶标”相关的漏洞报告。</font></p><h2 id="2资产有效性确认"><a class="markdownIt-Anchor" href="#2资产有效性确认"></a> 2.资产有效性确认</h2><p>进行资产有效性确认是网络安全和信息技术管理中的一个重要步骤。这可以防止在核对资产归属时发现，资产与本次靶标无关联的情况发生（也就是我们常说的“日偏了”）。</p><h2 id="3情报数据处理"><a class="markdownIt-Anchor" href="#3情报数据处理"></a> 3.情报数据处理</h2><ul><li><p>web资产</p><ul><li><p>存活测试（HTTPX）</p></li><li><p>指纹特征识别（Finger、云悉、Wapplyzer、WhatWeb等）</p></li><li><p>子域名（子域名挖掘机、OneForAll、Sublist3r等）</p></li><li><p>目录（御剑、dirmap、dirsearch、搜索语句等）</p></li></ul></li><li><p>IP</p><ul><li><p>常见端口/未授权访问漏洞常用端口/全量端口 -&gt;扫描</p></li><li><p>FOFA -&gt; C段信息</p></li></ul></li><li><p>邮箱</p><ul><li>邮箱有效性校验（<a href="http://mailtester.com">mailtester.com</a>、<a href="http://email-checker.net">email-checker.net</a>）</li></ul></li></ul><h2 id="4输出情报资产数据"><a class="markdownIt-Anchor" href="#4输出情报资产数据"></a> 4.输出情报资产数据</h2><h2 id="5入口权限获取"><a class="markdownIt-Anchor" href="#5入口权限获取"></a> 5.入口权限获取</h2><h2 id="6打点方式"><a class="markdownIt-Anchor" href="#6打点方式"></a> 6.打点方式</h2><ul><li><p>web资产</p><ul><li><p>漏洞场景识别（登录、上传、搜索、后台等）-&gt;根据漏洞场景优先检测对应的漏洞</p></li><li><p>CMS识别:漏洞利用(Nday、0day)</p></li><li><p>入口权限获取-常用漏洞:(Jboss、Struts2、Tomcat、Weblogic、Shiro、log4j2等)</p></li><li><p>网站设备:弱口令、命令执行、VPN</p></li><li><p>OA:泛微、通达、致远、金蝶</p></li></ul></li><li><p>IP</p><ul><li><p>端口爆破(超级弱口令检查工具-&gt;SSH、RDP、Mysql、FTP、Telnet等等)</p></li><li><p>未授权访问漏洞相关</p></li></ul></li><li><p>邮箱</p><ul><li><p>社工钓鱼:邮件收集、邮件文案、匿名邮箱、钓鱼方式(钓鱼链接、木马)等</p></li><li><p>邮箱登录场景:弱口令(TOP500、常用强逻辑密码字典)、逻辑漏洞、暴力破解/撞库</p></li><li><p>账号密码泄露(QQ群、giuhub、百度文库等)</p></li><li><p>邮箱系统:漏洞利用(Nday、0day)</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞扫描</title>
      <link href="/2024/08/23/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"/>
      <url>/2024/08/23/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>漏洞扫描是一种自动化的网络安全评估方法，旨在检测计算机系统、网络或网络应用程序中的安全漏洞。其基本目的是帮助组织识别和评估可能被黑客利用的安全缺陷，从而及时采取措施进行修复，以保护信息系统的安全。以下是漏洞扫描的几个关键点：</p><ol><li><p><strong>扫描过程</strong>：</p><ul><li><p><strong>信息收集</strong>：收集目标系统的相关信息，如操作系统类型、开放的服务和端口等。</p></li><li><p><strong>检测识别</strong>：根据收集的信息，检测系统中可能存在的已知漏洞。</p></li><li><p><strong>评估分析</strong>：分析检测到的漏洞，评估其可能对系统安全造成的影响。</p></li><li><p><strong>报告生成</strong>：生成详细的扫描报告，列出发现的漏洞和推荐的安全加固措施。</p></li></ul></li><li><p><strong>扫描类型</strong>：</p><ul><li><p><strong>网络扫描</strong>：检测网络中的设备和服务，如防火墙、路由器、交换机等。</p></li><li><p><strong>主机扫描</strong>：针对单个主机进行深入的漏洞检测。</p></li><li><p><strong>应用程序扫描</strong>：专注于Web应用程序或软件中的安全漏洞。</p></li></ul></li><li><p><strong>用途</strong>：</p><ul><li><p><strong>合规性要求</strong>：许多行业标准和法规要求定期进行漏洞扫描。</p></li><li><p><strong>风险管理</strong>：帮助组织了解其面临的安全风险，并进行优先级排序。</p></li><li><p><strong>安全加固</strong>：通过识别和修复漏洞来增强系统的安全性。</p></li></ul></li></ol><p>通过定期的漏洞扫描，组织可以及时发现并修复安全漏洞，降低被攻击的风险，是维护网络安全的重要措施之一。</p><hr /><h2 id="工具使用"><a class="markdownIt-Anchor" href="#工具使用"></a> 工具使用</h2><h3 id="流量转发"><a class="markdownIt-Anchor" href="#流量转发"></a> 流量转发</h3><ol><li><p>使用工具：Venom</p></li><li><p>使用方法：</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集（已完结）</title>
      <link href="/2024/08/14/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%EF%BC%88%E5%B7%B2%E5%AE%8C%E7%BB%93%EF%BC%89/"/>
      <url>/2024/08/14/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%EF%BC%88%E5%B7%B2%E5%AE%8C%E7%BB%93%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>网络攻防中的信息收集是网络安全防护和渗透测试过程中的重要环节。这一阶段的目标是尽可能地了解目标系统的详细信息，为后续的安全评估或攻击做准备。以下是一些信息收集的类别和方法：</p><h3 id="1-主动信息收集"><a class="markdownIt-Anchor" href="#1-主动信息收集"></a> 1. 主动信息收集</h3><p>主动信息收集可能会与目标系统产生交互，可能会被目标系统的安全设备检测到。</p><ul><li><p><strong>端口扫描</strong>：使用工具如Nmap扫描目标系统开放的端口，了解可能的服务。</p></li><li><p><strong>服务识别</strong>：识别端口上运行的具体服务版本，例如HTTP、FTP、SMTP等。</p></li><li><p><strong>漏洞扫描</strong>：利用漏洞扫描工具（如 Nessus）扫描已知漏洞。</p></li><li><p><strong>网络拓扑发现</strong>：绘制网络结构图，了解网络设备和它们之间的连接关系。</p></li></ul><h3 id="2-被动信息收集"><a class="markdownIt-Anchor" href="#2-被动信息收集"></a> 2. 被动信息收集</h3><p>被动信息收集尽量不与目标系统产生直接交互，减少被检测的风险。</p><ul><li><p><strong>DNS查询</strong>：搜集目标域名的DNS记录，如A记录、MX记录、TXT记录等。</p></li><li><p><strong>搜索引擎</strong>：利用Google hacking等搜索引擎技巧，查找与目标相关的信息。</p></li><li><p><strong>社交媒体和论坛</strong>：搜集员工或组织在社交媒体和行业论坛上发布的信息。</p></li><li><p><strong>公开信息查询</strong>：查询目标组织的公开信息，如企业注册信息、员工信息等。</p></li><li><p><strong>网络空间测绘</strong>：使用网络空间测绘工具搜集目标在互联网上的暴露面。</p></li></ul><h3 id="3-社会工程学"><a class="markdownIt-Anchor" href="#3-社会工程学"></a> 3. 社会工程学</h3><p>利用人性的弱点，通过欺骗、引诱等手段从人员那里获取信息。</p><ul><li><p><strong>钓鱼攻击</strong>：发送带有恶意链接或附件的邮件，诱骗目标点击或下载。</p></li><li><p><strong>伪装身份</strong>：假装成内部人员或合作伙伴，通过电话或邮件套取信息。</p></li></ul><h3 id="工具和技术"><a class="markdownIt-Anchor" href="#工具和技术"></a> 工具和技术</h3><ul><li><p><strong>Whois查询</strong>：查询域名的注册信息。</p></li><li><p><strong>网络爬虫</strong>：自动化地从网站上搜集信息。</p></li><li><p><strong>Maltego</strong>：一款信息收集和取证工具，可以用来图形化地展示收集到的信息。</p></li></ul><p>在进行信息收集时，应严格遵守法律法规，不得侵犯个人隐私和网络安全。对于企业和组织来说，了解这些信息收集的方法也很重要，以便采取相应的防护措施，保护自身的信息安全。在中国，网络安全法和相关的法律法规对网络信息收集和使用有严格的规定，任何个人和组织在进行网络信息收集时都应遵循法律规定，不得从事非法侵入、干扰、破坏网络系统的活动。</p><h1 id="域名信息"><a class="markdownIt-Anchor" href="#域名信息"></a> 域名信息</h1><h2 id="1whois信息"><a class="markdownIt-Anchor" href="#1whois信息"></a> 1.whois信息</h2><p>很多网站上都可以收集到whois信息，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">国外的who.is：https://who.is/   </span><br><span class="line">站长之家：http://whois.chinaz.com/  </span><br><span class="line">爱站：https://whois.aizhan.com/  </span><br><span class="line">微步：https://x.threatbook.cn/  </span><br></pre></td></tr></table></figure><p><strong>主要关注：注册商、注册人、邮件、DNS解析服务器、注册人联系电话。</strong><br /><font color=greee>小技巧：如果在站长之家上隐藏了信息，可在who.is上再次查看。</font></p><h2 id="2查企业的备案信息"><a class="markdownIt-Anchor" href="#2查企业的备案信息"></a> 2.查企业的备案信息</h2><p>主要有三种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">天眼查：https://www.tianyancha.com/  </span><br><span class="line">ICP备案查询网：http://www.beianbeian.com/  </span><br><span class="line">国家企业信用信息公示系统：http://www.gsxt.gov.cn/index.html </span><br></pre></td></tr></table></figure><p><strong>注意：国外的服务器一般来说是查不到的，因为他们不需要备案。国内的基本上都可以查到。</strong></p><h1 id="子域名信息"><a class="markdownIt-Anchor" href="#子域名信息"></a> 子域名信息</h1><h2 id="1google语法"><a class="markdownIt-Anchor" href="#1google语法"></a> 1.Google语法</h2><p>可以利用Google和Bing这样的搜索引擎进行搜索查询（<code>site:www.xxx.com</code>）<br />Google还支持额外的减号运算符，以排除我们对“网站:<code>wikimedia.org -www -store</code>”不感兴趣的子域名。</p><h2 id="2第三方服务器"><a class="markdownIt-Anchor" href="#2第三方服务器"></a> 2.第三方服务器</h2><p>有许多第三方服务聚合了大量的DNS数据集，并通过它们来检索给定域名的子域名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VirusTotal：https://www.virustotal.com/#/home/search </span><br><span class="line">DNSdumpster：https://dnsdumpster.com/ </span><br></pre></td></tr></table></figure><h2 id="3sublist3r"><a class="markdownIt-Anchor" href="#3sublist3r"></a> 3.Sublist3r</h2><p>Sublist3r是一款python开发的子域名枚举工具，通过各种搜索引擎 （例如Google，Yahoo，Bing，Baidu和Ask）枚举子域。Sublist3r还使用Netcraft，Virustotal，ThreatCrowd，DNSdumpster和ReverseDNS枚举子域。也集合了subbrute的暴力枚举功能。</p><h2 id="4基于ssl证书查询"><a class="markdownIt-Anchor" href="#4基于ssl证书查询"></a> 4.基于SSL证书查询</h2><p>查找一个域名证书的最简单方法是使用搜索引擎来收集计算机的CT日志，并让任何搜索引擎搜索它们。前两种比较常用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://crt.sh/</span><br><span class="line">https://censys.io/</span><br><span class="line">https://developers.facebook.com/tools/ct/</span><br><span class="line">https://google.com/transparencyreport/https/ct/</span><br></pre></td></tr></table></figure><h2 id="5简单的在线子域名收集不推荐"><a class="markdownIt-Anchor" href="#5简单的在线子域名收集不推荐"></a> 5.简单的在线子域名收集（不推荐）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://phpinfo.me/domain/</span><br><span class="line">http://i.links.cn/subdomain/</span><br></pre></td></tr></table></figure><h2 id="6爆破枚举"><a class="markdownIt-Anchor" href="#6爆破枚举"></a> 6.爆破枚举</h2><p>这个就有很多工具可以用了，比较常见的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）layer子域名挖掘机</span><br><span class="line">（2）subDomainsBrute</span><br><span class="line">（3）K8</span><br><span class="line">（4）orangescan</span><br><span class="line">（5）DNSRecon</span><br></pre></td></tr></table></figure><p>这里重点推荐<code>layaer</code>和<code>subDomainsBrute</code>工具，可以从子域名入侵到主站。</p><p><font color=greee>小技巧：在<a href="https://github.com/">https://github.com/</a> 上也可以搜索子域名，运气好的话，会有意想不到的收获。</font></p><h1 id="端口"><a class="markdownIt-Anchor" href="#端口"></a> 端口</h1><p>很多时候，网站都会开启CDN加速，导致我们查询到的IP不是真实的IP，所以得先查询到真实的IP地址。</p><ul><li><p>通过让服务器给你发邮件(看邮箱头源 ip )找真实ip（最可靠）。</p></li><li><p>通过 zmpap 全网爆破查询真实ip（可靠）。</p></li><li><p>通过查询域名历史ip，<a href="http://toolbar.netcraft.com">http://toolbar.netcraft.com</a>（借鉴）。</p></li><li><p>通过国外冷门的DNS的查询：nslookup xxx.com国外冷门DNS地址（借鉴）。</p></li></ul><p>收集到大量IP，那就要进行端口扫描了，看看有什么常见的漏洞。</p><p><em>kali linux自带NAMP可以扫描</em><br /><em>教程：<a href="https://blog.csdn.net/2302_82189125/article/details/135961736">https://blog.csdn.net/2302_82189125/article/details/135961736</a></em></p><p>知名端口漏洞<br />Github 详情：<a href="https://github.com/BestBDs/port-bug/blob/master/%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E6%BC%8F%E6%B4%9E">https://github.com/BestBDs/port-bug/blob/master/常见端口漏洞</a></p><h1 id="网站架构探测"><a class="markdownIt-Anchor" href="#网站架构探测"></a> 网站架构探测</h1><p>当我们探测目标站点网站架构时，比如操作系统，中间件，脚本语言，数据库，服务器，web容器等等，可以使用以下方法查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wappalyzer插件——火狐插件</span><br><span class="line">云悉：http://www.yunsee.cn/info.html</span><br><span class="line">查看数据包响应头</span><br><span class="line">CMS指纹识别：http://whatweb.bugscaner.com/look/ </span><br></pre></td></tr></table></figure><p>CMS指纹识别又有很多方法，比如说御剑指纹识别、Webrobot工具、whatweb工具、还有在线查询的网站等等。</p><p><em>kali linux自带whatweb可以扫描</em><br /><em>教程：<a href="https://blog.csdn.net/2302_82189125/article/details/135976188">https://blog.csdn.net/2302_82189125/article/details/135976188</a></em></p><h1 id="敏感信息收集"><a class="markdownIt-Anchor" href="#敏感信息收集"></a> 敏感信息收集</h1><p>通常我们所说的敏感文件、敏感目录大概有以下几种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Git</span><br><span class="line">hg/Mercurial</span><br><span class="line">svn/Subversion</span><br><span class="line">bzr/Bazaar</span><br><span class="line">Cvs</span><br><span class="line">WEB-INF泄露</span><br><span class="line">备份文件泄露、配置文件泄露</span><br></pre></td></tr></table></figure><p>敏感文件、敏感目录挖掘一般都是靠工具、脚本来找。</p><h2 id="1谷歌黑客"><a class="markdownIt-Anchor" href="#1谷歌黑客"></a> 1.谷歌黑客</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">site：指定域名</span><br><span class="line">inurl：指定url中存在的关键字</span><br><span class="line">intext：指定网页正文中的关键字</span><br><span class="line">filetype：指定文件类型</span><br><span class="line">intitle：指定网页标题中的关键字</span><br><span class="line">link：返回所有和link做了链接的url</span><br><span class="line">info：查找指定站点的一些基本信息</span><br><span class="line">cache：搜索Google里关于某些内容的缓存</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2024/08/14/46828bf9d91923f3.png" alt="" /></p><h2 id="2国内外ip地址查询"><a class="markdownIt-Anchor" href="#2国内外ip地址查询"></a> 2.国内/外IP地址查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">国内：https://www.17ce.com/</span><br><span class="line">国外：https://asm.ca.com/en/ping.php</span><br></pre></td></tr></table></figure><h2 id="3绕过cdn查询ip地址"><a class="markdownIt-Anchor" href="#3绕过cdn查询ip地址"></a> 3.绕过CDN查询IP地址</h2><p><a href="https://www.virustotal.com/gui/">https://www.virustotal.com/gui/</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP请求及Burp Suite的使用（更新中）</title>
      <link href="/2024/08/13/HTTP%E8%AF%B7%E6%B1%82%E5%8F%8ABurp%20Suite%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
      <url>/2024/08/13/HTTP%E8%AF%B7%E6%B1%82%E5%8F%8ABurp%20Suite%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>HTTP请求是客户端（通常是用户的网页浏览器）与服务器之间进行通信的一种方式。它遵循超文本传输协议（HTTP, Hypertext Transfer Protocol）的标准，用于在Web上传输数据。<br />以下是HTTP请求的基本组成部分和过程：</p><h3 id="1-http请求的组成部分"><a class="markdownIt-Anchor" href="#1-http请求的组成部分"></a> 1. HTTP请求的组成部分</h3><p>一个HTTP请求通常包含以下几个部分：</p><ul><li><p><strong>请求行</strong>：包括请求方法、URL和HTTP版本。</p></li><li><p><strong>请求头</strong>（Headers）：包含关于客户端环境和请求本身的信息，例如用户代理、内容类型、接受类型等。</p></li><li><p><strong>空行</strong>：请求头和请求体之间必须有一个空行。</p></li><li><p><strong>请求体</strong>（Body）：包含要发送给服务器的数据，不是所有请求都有请求体。</p></li></ul><h3 id="2-http请求方法"><a class="markdownIt-Anchor" href="#2-http请求方法"></a> 2. HTTP请求方法</h3><p>以下是一些常见的HTTP请求方法：</p><ul><li><p><strong>GET</strong>：请求指定的资源。</p></li><li><p><strong>POST</strong>：向服务器提交数据，通常用于提交表单或上传文件。</p></li><li><p><strong>PUT</strong>：更新服务器上的资源。</p></li><li><p><strong>DELETE</strong>：删除服务器上的资源。</p></li><li><p><strong>HEAD</strong>：类似于GET请求，但服务器不会返回请求体，只返回响应头。</p></li><li><p><strong>OPTIONS</strong>：用于描述目标资源的通信选项。</p></li><li><p><strong>PATCH</strong>：用于对资源进行部分更新。</p></li></ul><h3 id="3-例子"><a class="markdownIt-Anchor" href="#3-例子"></a> 3. 例子</h3><p>以下是一个简单的HTTP GET请求的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><p><code>GET</code> 是请求方法。</p></li><li><p><code>/index.html</code> 是请求的资源。</p></li><li><p><code>HTTP/1.1</code> 是使用的HTTP版本。</p></li><li><p><code>Host</code> 是请求的服务器地址。</p></li><li><p>其他行都是请求头，提供了关于客户端环境和请求的附加信息。</p></li></ul><h3 id="4-发起http请求"><a class="markdownIt-Anchor" href="#4-发起http请求"></a> 4. 发起HTTP请求</h3><p>可以通过多种方式发起HTTP请求：</p><ul><li><p><strong>浏览器</strong>：用户在浏览器地址栏输入URL或点击链接时，浏览器会发起HTTP请求。</p></li><li><p><strong>cURL</strong>：命令行工具，常用于服务器端脚本或在命令行中发起HTTP请求。</p></li><li><p><strong>编程语言</strong>：大多数编程语言都提供了HTTP请求的库或模块，例如Python的<code>requests</code>库、JavaScript的<code>fetch</code> API等。</p></li></ul><h3 id="5-响应"><a class="markdownIt-Anchor" href="#5-响应"></a> 5. 响应</h3><p>服务器在接收到HTTP请求后，会处理请求并返回一个HTTP响应，响应包含状态码（如200表示成功）、响应头和响应体。</p><p>HTTP请求和响应是Web工作的基础，对于Web开发人员来说，理解HTTP请求的细节对于调试和优化Web应用至关重要。</p><h1 id="burp-suite工具proxy-intruder-repeater使用"><a class="markdownIt-Anchor" href="#burp-suite工具proxy-intruder-repeater使用"></a> Burp Suite工具（Proxy、Intruder、Repeater）使用</h1><h2 id="1proxy-模块的使用"><a class="markdownIt-Anchor" href="#1proxy-模块的使用"></a> 1.Proxy 模块的使用</h2><p>Burp Suite中的Proxy模块是其中一个最常用和最强大的模块之一，它允许用户拦截、查看和修改Web应用程序的HTTP和HTTPS流量，使用户能够识别和利用各种不同类型的漏洞。Proxy模块又分为四部分，分别是Intercept(拦截)，HTTP history，WebSockets history，Option(选项)。</p><p>下面是对四部分的基本解释：</p><ol><li><p><strong>Intercept（拦截）</strong>:</p><ul><li><p>拦截功能允许Proxy服务器监控并修改客户端和服务器之间的数据传输。</p></li><li><p>开发者可以利用这个功能来调试应用，例如查看、修改请求和响应。</p></li><li><p>安全测试人员可能会用它来注入攻击载荷，测试应用的漏洞。</p></li><li><p>该模块功能如图所示：</p></li></ul></li></ol><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d4edc8579687a4ae69431e352f5f29a2.png" alt="" /></p><ol start="2"><li><p><strong>HTTP history</strong>:</p><ul><li><p>HTTP历史记录了通过Proxy的所有HTTP请求的详细信息。</p></li><li><p>这包括请求的方法、URL、头部信息、发送的数据和从服务器接收的响应。</p></li><li><p>开发者可以通过历史记录来分析应用的行为，检查错误，优化性能。</p></li><li><p>该模块功能如图所示：</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8c5d9f68fe52589dcad4eb04362f4926.png" alt="" /></p></li><li><p><strong>WebSockets history</strong>:</p><ul><li><p>WebSocket历史记录了WebSocket连接的详细信息，这包括打开的连接、通过连接发送的消息和从服务器接收的消息。</p></li><li><p>WebSocket是一种在单个TCP连接上进行全双工通信的协议，常用于需要快速、实时通信的应用，如在线游戏、实时交易系统等。</p></li><li><p>通过查看WebSocket历史，开发者可以调试和优化实时通信功能。</p></li><li><p>该模块功能如图所示：</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fc7c0e91aec7b662c9a13cb425474aff.png" alt="" /></p></li><li><p><strong>Option（选项）</strong>:</p><ul><li><p>选项部分允许用户配置Proxy的行为。</p></li><li><p>这可能包括设置规则来拦截特定的请求，配置证书用于解密HTTPS流量，设置流量规则，以及调整其他各种代理设置。</p></li><li><p>通过这些选项，用户可以根据自己的需求定制Proxy的工作方式。</p></li><li><p>该模块功能如图所示：</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ec979601a91f43a84249ca206eba8977.png" alt="" /><br /><img src="https://i-blog.csdnimg.cn/blog_migrate/17fe9e2f787479c4da81eb07e323327c.png" alt="" /><br /><img src="https://i-blog.csdnimg.cn/blog_migrate/d6a8275746d078410d9dbc46354a63e3.png" alt="" /><br /><img src="https://i-blog.csdnimg.cn/blog_migrate/d6a8275746d078410d9dbc46354a63e3.png" alt="" /><br /><img src="https://i-blog.csdnimg.cn/blog_migrate/8cc5c2c82bfcef92877ea0c9c311c1d8.png" alt="" /><br /><img src="https://i-blog.csdnimg.cn/blog_migrate/cb432bfe5e294cb4d37ce38c271c3774.png" alt="" /><br /><img src="https://i-blog.csdnimg.cn/blog_migrate/cb432bfe5e294cb4d37ce38c271c3774.png" alt="" /></p></li></ol><h2 id="2intruder-模块的使用"><a class="markdownIt-Anchor" href="#2intruder-模块的使用"></a> 2.Intruder 模块的使用</h2><p>Burp Suite的Intruder模块是一个非常强大的工具，用于自动化定制攻击以发现Web应用程序中的安全漏洞。以下是简要介绍：</p><h3 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能：</h3><ol><li><p><strong>攻击类型</strong>:</p><ul><li><p><strong>Sniper</strong>：使用相同的载荷集合，一次更改一个目标位置。</p></li><li><p><strong>Battering ram</strong>：使用相同的载荷集合，同时更改所有目标位置。</p></li><li><p><strong>Pitchfork</strong>：为每个目标位置使用不同的载荷集合，组合不同的载荷。</p></li><li><p><strong>Cluster bomb</strong>：为每个目标位置使用不同的载荷集合，尝试所有可能的载荷组合。</p></li></ul></li><li><p><strong>目标</strong>:</p><ul><li>用户可以指定HTTP请求中的哪些部分（如参数、头、cookie等）作为攻击的目标位置。</li></ul></li><li><p><strong>载荷</strong>:</p><ul><li><p>Intruder允许用户从文件、自定义列表或内置的 payloads 列表中选择载荷。</p></li><li><p>支持使用变量和宏来生成复杂的载荷。</p></li></ul></li><li><p><strong>攻击配置</strong>:</p><ul><li>用户可以配置攻击的详细信息，如并发线程数、请求延迟、重试策略等。</li></ul></li><li><p><strong>结果分析</strong>:</p><ul><li><p>Intruder捕获每个请求的响应，并允许用户根据响应长度、状态码、响应时间或其他自定义参数来筛选和排序结果。</p></li><li><p>支持使用正则表达式来识别感兴趣的响应模式。</p></li></ul></li></ol><h3 id="使用步骤"><a class="markdownIt-Anchor" href="#使用步骤"></a> 使用步骤：</h3><ol><li><p><strong>发送请求</strong>:</p><ul><li><p>在浏览器或其他Burp工具（如Proxy或Repeater）中捕获一个HTTP请求。</p></li><li><p>将该请求发送到Intruder模块。</p></li></ul></li><li><p><strong>配置攻击</strong>:</p><ul><li><p>选择攻击类型。</p></li><li><p>标记目标位置。</p></li><li><p>选择或创建载荷。</p></li></ul></li><li><p><strong>启动攻击</strong>:</p><ul><li><p>配置攻击选项并启动攻击。</p></li><li><p>Intruder开始发送请求并捕获响应。</p></li></ul></li><li><p><strong>分析结果</strong>:</p><ul><li><p>查看结果表格，分析异常或有趣的响应。</p></li><li><p>使用结果过滤器来识别潜在的漏洞。</p></li></ul></li></ol><h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景：</h3><ul><li><p><strong>密码破解</strong>：通过自动化尝试密码组合来破解登录表单。</p></li><li><p><strong>参数篡改</strong>：测试应用程序对异常输入的响应。</p></li><li><p><strong>目录/文件枚举</strong>：发现Web服务器上的隐藏目录或文件。</p></li><li><p><strong>SQL注入</strong>：检测和利用SQL注入漏洞。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e90df3902de09cafcef6d6c7cbf9ca7f.png" alt="" /><br />该模块界面如上图所示。</p><p>由四个部分组成：</p><ol><li>Target（目标）：攻击的目标URL或网站。</li><li>Positions（位置）：在HTTP请求中插入负载的位置，如GET参数、POST表单字段等。</li><li>Payloads（负载）：要插入到请求中的数据，可以是文本、二进制文件或其他类型的数据。</li><li>Options（选项）：附加的设置或配置，例如攻击类型、延迟时间、重复次数等。</li></ol><h3 id="position部分"><a class="markdownIt-Anchor" href="#position部分"></a> Position部分</h3><p><strong>Intruder模块的测试模式分为4种：</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b5229292e85046aac022caf3fb14f406.png" alt="" /></p><ul><li><p>Sniper(Sniper)：逐个地对每个目标参数进行测试。这种方式适用于需要具体指定某个参数值进行测试的情况。</p></li><li><p>Battering Ram(破城槌)：选择多个不同的参数值集合作为测试数据进行并行测试，以找出所有可能的漏洞点。这种方式适用于需要大量测试数据的情况。</p></li><li><p>Pitchfork(干草叉)：同时对多个参数进行测试，将不同的参数组合在一起进行测试。这种方式适用于需要测试多个参数交互情况的情况。</p></li><li><p>Cluster Bomb(集束炸弹)：类似于Battering Ram，不同之处在于它将多个参数值集合作为测试数据，但会对每个参数集合都进行逐次的单元素组合测试。这种方式适用于需要详细测试每个参数值的情况。</p></li></ul><p>说人话：</p><ul><li><strong>Sniper</strong><br />就是爆破单个位置，你指定哪就爆破哪<br />如下图，就是不同的用户名，密码不变为123456。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangsan 123456  </span><br><span class="line">lisi 123456  </span><br><span class="line">wangwu 123456  </span><br></pre></td></tr></table></figure><ul><li><strong>Battering Ram</strong><br />指定多个位置 他只需要你一个字典文件，所有位置的参数一样。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">admin admin  </span><br><span class="line">1111 1111  </span><br><span class="line">zhangsan zhangsan  </span><br><span class="line">lisi lisi  </span><br></pre></td></tr></table></figure><ul><li><strong>Pitchfork(干草叉)</strong><br />一般加入两个变量值进去，比如说dict1: admin,test,root dict2: 123456, admin123,root.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">admin 123456  </span><br><span class="line">test admin123  </span><br><span class="line">root root  </span><br></pre></td></tr></table></figure><ul><li><strong>Cluster Bomb(集束炸弹)</strong><br />一般加入两个变量值进去，比如说dict1: admin,test,root dict2: 123456, admin123,root.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">admin 123456</span><br><span class="line">admin admin123</span><br><span class="line">admin root</span><br><span class="line">test 123456</span><br><span class="line">test admin123</span><br><span class="line">test root</span><br><span class="line">root 123456</span><br><span class="line">root admin123</span><br><span class="line">root root</span><br></pre></td></tr></table></figure><h3 id="payloads部分"><a class="markdownIt-Anchor" href="#payloads部分"></a> Payloads部分</h3><p>在Payload Type选项中共有：<code>Simple list</code>，<code>Runtime file</code>，<code>Custom iterator</code>，<code>Character substitution</code>，<code>Case modification</code>，<code>Recursive grep</code>，<code>Illegal Unicode</code>，<code>Character blocks</code>，<code>Numbers</code>，<code>Dates</code>，<code>Brute forcer</code>，<code>Null payloads</code>，<code>Character frobber</code>，<code>Bit flipper</code>，<code>Username generator</code>，<code>ECB block shuffler</code>，<code>Extension-generated</code>，<code>Copy other payload</code> 这18种类型，接下来我将一一介绍。</p><p><strong>1.Simple list(简单列表)</strong></p><ul><li><p>描述：提供一组预定义的payload列表。这些payload可以是手动输入的，也可以是从文件中导入的。</p></li><li><p>用途：适用于当已知一组特定的测试用例，需要重复测试这些用例时。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/13f5998e05041f20ede1ae52dc42dcbf.png" alt="" /></p><p><strong>2.Runtime file（运行时文件）</strong></p><ul><li><p>描述：引用一个外部文件，该文件在测试过程中可以动态更新。</p></li><li><p>用途：当payload需要实时更新，或者是从其他工具或脚本生成的动态列表时。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ff0813936a7940c31a91b3f12657e970.png" alt="" /></p><p><strong>3.Custom iterator(自定义迭代)</strong></p><ul><li><p>描述：基于多个参数的笛卡尔积生成payload。可以设置多个参数，每个参数都有自己的值列表。</p></li><li><p>用途：用于需要测试大量组合的情况，如参数化攻击。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/67f52444daf97a2ebab1f691e8d8d331.png" alt="" /></p><p><strong>4.Character substitution(单个字符替换)</strong></p><ul><li><p>描述：将payload中的字符替换为指定的替代字符。</p></li><li><p>用途：测试字符编码问题或输入过滤器的绕过。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/311c3e212c6ea7fd70eb29c541544cd0.png" alt="" /></p><p><strong>5.Case modification（大小写替换）</strong></p><ul><li><p>描述：生成原始payload的所有大小写变体。</p></li><li><p>用途：测试应用程序是否对大小写敏感。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/158418619c7df200d078fca60b0031ad.png" alt="" /></p><p><strong>6.Recursive grep（递归grep）</strong></p><ul><li><p>描述：从应用程序的响应中提取信息，并使用这些信息作为新的payload。</p></li><li><p>用途：发现并利用应用程序的动态行为。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a6f7b9e2f1d91430f595ce4915214575.png" alt="" /></p><p><strong>7. Illegal Unicode</strong></p><ul><li><p>描述：生成包含非法Unicode字符序列的payload。</p></li><li><p>用途：测试应用程序对异常或非法字符序列的处理。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4a5742563baaae32c2329f759df25c3e.png" alt="" /></p><p><strong>8. Character blocks</strong></p><ul><li><p>描述：生成包含预定义字符块（如字母、数字、符号等）的payload。</p></li><li><p>用途：测试应用程序对特定字符集的过滤和验证。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/11fa18c31c361cf596f2b29cc0ea9f75.png" alt="" /></p><p><strong>9. Numbers</strong></p><ul><li><p>描述：生成一系列数字，可以指定起始值、结束值和步长。</p></li><li><p>用途：测试数字输入字段，例如ID、序列号或日期。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3edf20d338ab9b7e9ec0a1f24c706358.png" alt="" /></p><p><strong>10. Dates</strong></p><ul><li><p>描述：生成一系列日期，可以指定日期格式、起始日期和结束日期。</p></li><li><p>用途：测试日期输入字段，特别是格式化错误或SQL注入。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5db1b03c411c4ec9dc257367cb694be9.png" alt="" /></p><p><strong>11. Brute forcer</strong></p><ul><li><p>描述：基于预定义的字符集和长度范围生成payload。</p></li><li><p>用途：用于执行暴力破解攻击，如密码破解。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c34d905b1695c719884097aa3c22221a.png" alt="" /></p><p><strong>12. Null payloads</strong></p><ul><li><p>描述：生成空或null的payload。</p></li><li><p>用途：测试应用程序如何处理空值或缺失的参数。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c68bbbee38d52e8fb36ea2443b8f6e50.png" alt="" /></p><p><strong>13. Character frobber</strong></p><ul><li><p>描述：随机修改原始payload中的字符，通常用于测试缓冲区溢出。</p></li><li><p>用途：检测应用程序对字符变异的稳健性。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c4780d56693d7de5692a4a7470edbf4a.png" alt="" /></p><p><strong>14. Bit flipper</strong></p><ul><li><p>描述：对原始payload中的每个字符进行位翻转操作。</p></li><li><p>用途：测试应用程序对数据损坏的敏感度。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b95195bf9f6e49b5cd37e76f3dbe98bc.png" alt="" /></p><p><strong>15. Username generator</strong></p><ul><li><p>描述：结合常见的前缀、后缀和单词列表生成用户名字符串。</p></li><li><p>用途：用于测试用户认证机制，特别是当需要猜测或枚举用户名时。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/96ee1536136d2204a8872a67e9e45b8e.png" alt="" /></p><p><strong>16.ECB block shuffler</strong></p><ul><li><p>描述：这个payload类型专门用于测试基于ECB（Electronic Codebook）模式的加密。它会对加密块进行重新排列，以尝试破坏加密数据的完整性或发现模式。</p></li><li><p>用途：用于检测加密实现中的弱点，尤其是当使用ECB模式时，该模式因其对相同明文块产生相同密文块的特性而容易受到某些类型攻击的影响。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7266d16f33b67d4aac01986ff292fee3.png" alt="" /></p><p><strong>17.Extension-generated</strong></p><ul><li><p>描述：这种payload类型允许用户使用Burp Suite的扩展来生成payload。这意味着任何编写了Burp扩展的开发者都可以创建自定义的payload生成器。</p></li><li><p>用途：当内置的payload类型不足以满足特定测试需求时，可以使用扩展来生成更复杂的payload。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3858231f870c2490ef963a67147edbdb.png" alt="" /></p><p><strong>18.Copy other payload</strong></p><ul><li><p>描述：这个payload类型允许用户从一个payload位置复制另一个位置的payload。例如，你可以将一个请求参数的值复制到另一个参数中。</p></li><li><p>用途：当需要在不同的位置测试相同的payload，或者需要根据其他参数的值动态生成payload时，这个功能非常有用。</p></li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c5ef76a6817cff29fcfd08b06c46cf8f.png" alt="" /></p><h2 id="3target-模块的使用"><a class="markdownIt-Anchor" href="#3target-模块的使用"></a> 3.Target 模块的使用</h2><p>Target模块是一个功能强大的工具，用于管理和分析在渗透测试期间涉及的目标应用程序。以下是Target模块的简要介绍：</p><ul><li><p><strong>功能</strong>：Target模块提供了一个结构化的视图，帮助测试人员理解目标应用程序的结构、功能和潜在的安全漏洞。</p></li><li><p><strong>站点地图</strong>：该模块的核心是站点地图，它以可视化的方式展示应用程序的URL结构，包括所有的页面、目录和参数。</p></li><li><p><strong>应用程序分析</strong>：</p><ul><li><strong>Scope</strong>：允许测试人员定义测试的范围，包括哪些URL应该包含在测试中，哪些应该排除。</li><li><strong>Annotations</strong>：可以在站点地图上添加注释，记录观察到的信息或未来的测试计划。</li><li><strong>Issues</strong>：Target模块会显示由其他Burp工具（如Scanner、Intruder等）发现的安全问题。</li></ul></li><li><p><strong>内容发现</strong>：</p><ul><li><strong>Spider</strong>：Target模块可以启动Spider工具来自动发现应用程序的内容。</li><li><strong>Scanner</strong>：可以启动Scanner工具来自动识别已知的安全漏洞。</li></ul></li><li><p><strong>手动测试</strong>：</p><ul><li><strong>Repeater</strong>：Target模块允许将请求发送到Repeater工具进行手动测试和修改。</li><li><strong>Decoder</strong>：可以快速解码或编码URL、HTML实体等。</li></ul></li><li><p><strong>配置和监控</strong>：</p><ul><li><strong>Cookies</strong>：可以查看和管理应用程序的cookies。</li><li><strong>WebSockets</strong>：支持监控和分析WebSocket通信。</li><li><strong>HTTP请求和响应</strong>：Target模块可以记录所有的HTTP请求和响应，便于后续分析。</li></ul></li><li><p><strong>报告</strong>：</p><ul><li>Target模块可以生成详细的报告，总结应用程序的安全状况和发现的问题。</li></ul></li></ul><p>总的来说，Target模块是Burp Suite的一个组织中心，它帮助测试人员更好地理解、管理和测试目标应用程序，同时确保测试活动是有序和高效的。</p><p>接下来我将开始学习如何使用Target模块。</p><h3 id="1site-map"><a class="markdownIt-Anchor" href="#1site-map"></a> 1.Site map</h3><h3 id="2scope"><a class="markdownIt-Anchor" href="#2scope"></a> 2.Scope</h3><h3 id="3issue-definitions"><a class="markdownIt-Anchor" href="#3issue-definitions"></a> 3.Issue definitions</h3><hr /><ul><li><p>声明：本文借鉴自CSDN平台文章</p></li><li><p>原文链接：</p><ul><li><a href="https://blog.csdn.net/Javachichi/article/details/135837378">https://blog.csdn.net/Javachichi/article/details/135837378</a></li><li><a href="https://blog.csdn.net/2201_75735270/article/details/137224361">https://blog.csdn.net/2201_75735270/article/details/137224361</a></li><li><a href="https://blog.csdn.net/elmoyan/article/details/127243467">https://blog.csdn.net/elmoyan/article/details/127243467</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入（更新中）</title>
      <link href="/2024/08/13/SQL%E6%B3%A8%E5%85%A5%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
      <url>/2024/08/13/SQL%E6%B3%A8%E5%85%A5%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>SQL注入是一种常见的网络攻击技术，它主要针对基于SQL语言的数据库系统。攻击者通过在Web应用的输入字段或者URL参数中输入恶意的SQL代码，这些代码在后端数据库执行时，能够绕过正常的访问控制，非法读取、修改、删除数据库中的数据，甚至有可能控制数据库管理系统。</p><p>下面简要介绍一下SQL注入的工作原理：</p><ol><li><p><strong>输入验证不严格</strong>：当应用程序没有正确地验证或者转义用户的输入，就有可能发生SQL注入。</p></li><li><p><strong>构造恶意输入</strong>：攻击者会在输入字段中输入特殊的SQL语句片段，这些片段会在原有SQL查询的基础上，改变其语义。</p></li><li><p><strong>SQL语句拼接</strong>：应用程序在处理用户输入时，如果没有正确处理，可能会直接将其拼接到SQL查询语句中。</p></li><li><p><strong>执行恶意SQL</strong>：拼接后的SQL语句被发送到数据库执行，恶意部分也得以执行。</p></li><li><p><strong>获取数据或权限</strong>：通过执行恶意的SQL语句，攻击者可以读取敏感数据、修改数据库内容、甚至执行数据库管理系统中的命令。</p></li></ol><p>例如，一个基于SQL的登录查询，如果不对用户输入进行适当的处理，可能如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;[用户输入的用户名]&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;[用户输入的密码]&#x27;</span></span><br></pre></td></tr></table></figure><p>如果攻击者在用户名输入框中输入 <code>admin' --</code>（注意，这里 <code>--</code> 是SQL中的注释符号，表示其后的内容被忽略），那么实际的SQL查询可能会变成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="comment">--&#x27; AND password = &#x27;[任何密码]&#x27;</span></span><br></pre></td></tr></table></figure><p>这样，密码部分被注释掉，攻击者无需知道密码即可通过认证。</p><p><strong>防护措施</strong>：</p><ul><li><p>使用预编译的SQL语句（参数化查询）。</p></li><li><p>对所有用户输入进行严格的验证和转义。</p></li><li><p>限制数据库操作的权限，遵循最小权限原则。</p></li><li><p>定期进行安全审计和测试，包括SQL注入漏洞的检测。</p></li><li><p>使用专业的安全工具和框架来防御SQL注入攻击。</p></li></ul><h2 id="什么是sql注入"><a class="markdownIt-Anchor" href="#什么是sql注入"></a> 什么是SQL注入？</h2>]]></content>
      
      
      <categories>
          
          <category> CTF study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量分析</title>
      <link href="/2024/08/13/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
      <url>/2024/08/13/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="例题陇剑杯2021-webshell-7问"><a class="markdownIt-Anchor" href="#例题陇剑杯2021-webshell-7问"></a> 例题：陇剑杯2021 webshell 7问</h2><h3 id="问1"><a class="markdownIt-Anchor" href="#问1"></a> 问1</h3><ul><li>单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：<br />黑客登录系统使用的密码是_____________。</li></ul><p>在wireshake打开流量包，搜索*http contains “password”*找到密码。<br /><img src="https://s3.bmp.ovh/imgs/2024/09/25/662584bfd3916b1b.png" alt="" /></p><h3 id="问2"><a class="markdownIt-Anchor" href="#问2"></a> 问2</h3><ul><li>单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：<br />黑客修改了一个日志文件，文件的绝对路径为_____________。（请确认绝对路径后再提交）</li></ul><p>搜索<em>http contains “log” &amp;&amp; http.request.method == POST</em>，找到日志文件的绝对路径。<br /><img src="https://s3.bmp.ovh/imgs/2024/09/25/4835883a25cd03b3.png" alt="" /><br />上面一段和下面一段需要拼接（第一段的data和第二段的1.php是同级）</p><h3 id="问3"><a class="markdownIt-Anchor" href="#问3"></a> 问3</h3><ul><li>单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：<br />黑客获取webshell之后，权限是______？</li></ul><p>搜索<em>whoami</em>，发现317-319有回显<br /><img src="https://s3.bmp.ovh/imgs/2024/09/25/29bfb2eafaaa09d1.png" alt="" /><br /><img src="https://s3.bmp.ovh/imgs/2024/09/25/4cc261468ef084e0.png" alt="" /><br />在319中找到flag<br /><img src="https://s3.bmp.ovh/imgs/2024/09/25/f700c1c78f5572e1.png" alt="" /></p><h3 id="问4"><a class="markdownIt-Anchor" href="#问4"></a> 问4</h3><ul><li>单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：<br />黑客写入的webshell文件名是_____________。(请提交带有文件后缀的文件名，例如x.txt)</li></ul><p>在不远处就看到了1.php<br /><img src="https://s3.bmp.ovh/imgs/2024/09/25/93eca2bbfe4cd572.png" alt="" /></p><h3 id="问5"><a class="markdownIt-Anchor" href="#问5"></a> 问5</h3><ul><li>单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：<br />黑客上传的代理工具客户端名字是_____________。</li></ul><p>在最末一行找到上传工具。<br /><a href="https://postimg.cc/HrHDpp2Q"><img src="https://i.postimg.cc/Hk8p9n8P/image.png" alt="image.png" /></a></p><h3 id="问6"><a class="markdownIt-Anchor" href="#问6"></a> *问6</h3><ul><li>单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：<br />黑客代理工具的回连服务端IP是_____________。<br />因为是回连端，所以和前面的1.php肯定有关系，所以直接搜索<em>http contains “1.php”</em>。<br /><img src="https://s3.bmp.ovh/imgs/2024/10/08/68192388e474d42f.png" alt="" /><br />在343中有较短的一段回应，拿去解密。<br /><img src="https://s3.bmp.ovh/imgs/2024/10/08/5086dda7657a742a.png" alt="" /></li></ul><h3 id="问7"><a class="markdownIt-Anchor" href="#问7"></a> *问7</h3><ul><li>单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：<br />黑客的socks5的连接账号、密码是______。（中间使用#号隔开，例如admin#passwd）。<br />没错，还是这张图。图中已经给出了<em>plugin_user</em>和<em>plugin_passwd</em>，直接写就行。<br /><img src="https://s3.bmp.ovh/imgs/2024/10/08/5086dda7657a742a.png" alt="" /></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图片隐写</title>
      <link href="/2024/08/13/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/"/>
      <url>/2024/08/13/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h2 id="1修改png图片宽高"><a class="markdownIt-Anchor" href="#1修改png图片宽高"></a> 1.修改png图片宽高</h2><p><em>eg.LitCTF2023_羽毛球</em><br />开始时题目中提到“羽毛球不完整”“下半身是什么”，所以会很自然的想到图片的宽高出了问题。<br /><img src="https://s3.bmp.ovh/imgs/2024/09/25/d09438f5aaaee8aa.png" alt="" /><br />所以用010editor打开，修改图片高度。<br /><img src="https://s3.bmp.ovh/imgs/2024/09/25/aae576286291e4d1.png" alt="" /><br />然后输出图片为flag.png。<br /><img src="https://s3.bmp.ovh/imgs/2024/09/25/904b0755dd999d4a.png" alt="" /><br />就可以得到flag了。</p><p><em>ps:我是直接修改图片高度，当然也可以通过CRC检测的方式算出正确的宽高。</em></p><h2 id="2基于svd的数字水印模型"><a class="markdownIt-Anchor" href="#2基于svd的数字水印模型"></a> 2.基于svd的数字水印模型</h2><p><em>eg.KPCTF2024_watermark</em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数学建模竞赛培训</title>
      <link href="/2024/08/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B%E5%9F%B9%E8%AE%AD/"/>
      <url>/2024/08/01/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B%E5%9F%B9%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="数学建模竞赛介绍"><a class="markdownIt-Anchor" href="#数学建模竞赛介绍"></a> 数学建模竞赛介绍</h1><p>全国大学生数学建模竞赛（CUMCM）<br />时间：2024.9.5 18：00 至 2024.9.8 20：00  共74小时<br />题目：三选一<br />报名费：CNY300<br /><img src="https://s3.bmp.ovh/imgs/2024/08/02/042aa8037db40eda.png" alt="" /></p><h1 id="线性规划和整数规划模型"><a class="markdownIt-Anchor" href="#线性规划和整数规划模型"></a> 线性规划和整数规划模型</h1><p>eg1:<br />2023年高教社杯全国大学生数学建模竞赛题目A题:定日镜场的优化设计</p><h1 id="非线性规划和多目标规范模型"><a class="markdownIt-Anchor" href="#非线性规划和多目标规范模型"></a> 非线性规划和多目标规范模型</h1><h1 id="常微分方程"><a class="markdownIt-Anchor" href="#常微分方程"></a> 常微分方程</h1><h1 id="差分方程"><a class="markdownIt-Anchor" href="#差分方程"></a> 差分方程</h1><h1 id="偏微分方程"><a class="markdownIt-Anchor" href="#偏微分方程"></a> 偏微分方程</h1><p>偏微分方程用于求解有明显公式的物理问题。例如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mi>m</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F=ma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>k</mi></msub><mo>=</mo><mi>m</mi><mi>g</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">E_k=mgh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>=</mo><mi>d</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">v=ds/dt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mord">/</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span><br />引例：热传导方程：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>t</mi></msub><mo>=</mo><mi>k</mi><mi mathvariant="normal">Δ</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">u_t=k\Delta u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord">Δ</span><span class="mord mathnormal">u</span></span></span></span></p><h2 id="1三类偏微分方程的定解问题"><a class="markdownIt-Anchor" href="#1三类偏微分方程的定解问题"></a> 1.三类偏微分方程的定解问题</h2><h3 id="11"><a class="markdownIt-Anchor" href="#11"></a> 1.1</h3><h3 id="12"><a class="markdownIt-Anchor" href="#12"></a> 1.2</h3><h3 id="13-双曲型偏微分方程"><a class="markdownIt-Anchor" href="#13-双曲型偏微分方程"></a> 1.3 双曲型偏微分方程</h3><h1 id="python数学建模基础"><a class="markdownIt-Anchor" href="#python数学建模基础"></a> Python数学建模基础</h1><h1 id="插值方法"><a class="markdownIt-Anchor" href="#插值方法"></a> 插值方法</h1><h1 id="最短路问题-最小生成树问题"><a class="markdownIt-Anchor" href="#最短路问题-最小生成树问题"></a> 最短路问题、最小生成树问题</h1><h1 id="最大流与最小费用问题"><a class="markdownIt-Anchor" href="#最大流与最小费用问题"></a> 最大流与最小费用问题</h1><h1 id="背包问题-指派问题-旅行商问题"><a class="markdownIt-Anchor" href="#背包问题-指派问题-旅行商问题"></a> 背包问题、指派问题、旅行商问题</h1><h1 id="智能优化算法"><a class="markdownIt-Anchor" href="#智能优化算法"></a> 智能优化算法</h1><h1 id="matlab软件处理1"><a class="markdownIt-Anchor" href="#matlab软件处理1"></a> Matlab软件处理1</h1><h1 id="matlab软件处理2"><a class="markdownIt-Anchor" href="#matlab软件处理2"></a> Matlab软件处理2</h1><h1 id="数据处理方法python"><a class="markdownIt-Anchor" href="#数据处理方法python"></a> 数据处理方法（Python）</h1><h1 id="统计分析方法"><a class="markdownIt-Anchor" href="#统计分析方法"></a> 统计分析方法</h1><h1 id="回归模型与分析"><a class="markdownIt-Anchor" href="#回归模型与分析"></a> 回归模型与分析</h1><h1 id="聚类分析方法与判别分析"><a class="markdownIt-Anchor" href="#聚类分析方法与判别分析"></a> 聚类分析方法与判别分析</h1><h1 id="主成分分析方法数据降维"><a class="markdownIt-Anchor" href="#主成分分析方法数据降维"></a> 主成分分析方法（数据降维）</h1><h1 id="预测方法"><a class="markdownIt-Anchor" href="#预测方法"></a> 预测方法</h1><h1 id="spss统计分析"><a class="markdownIt-Anchor" href="#spss统计分析"></a> SPSS统计分析</h1><h1 id="几何模型"><a class="markdownIt-Anchor" href="#几何模型"></a> 几何模型</h1><h1 id="博弈模型"><a class="markdownIt-Anchor" href="#博弈模型"></a> 博弈模型</h1><h1 id="综合评价方法"><a class="markdownIt-Anchor" href="#综合评价方法"></a> 综合评价方法</h1><h1 id="数字图像处理"><a class="markdownIt-Anchor" href="#数字图像处理"></a> 数字图像处理</h1><h1 id="数学建模竞赛论文写作"><a class="markdownIt-Anchor" href="#数学建模竞赛论文写作"></a> 数学建模竞赛论文写作</h1><h1 id="2022年全国大学生数学建模竞赛a题"><a class="markdownIt-Anchor" href="#2022年全国大学生数学建模竞赛a题"></a> 2022年全国大学生数学建模竞赛A题</h1><h1 id="2022年全国大学生数学建模竞赛b题"><a class="markdownIt-Anchor" href="#2022年全国大学生数学建模竞赛b题"></a> 2022年全国大学生数学建模竞赛B题</h1><h1 id="2022年全国大学生数学建模竞赛c题"><a class="markdownIt-Anchor" href="#2022年全国大学生数学建模竞赛c题"></a> 2022年全国大学生数学建模竞赛C题</h1><h1 id="2023年全国大学生数学建模竞赛a题"><a class="markdownIt-Anchor" href="#2023年全国大学生数学建模竞赛a题"></a> 2023年全国大学生数学建模竞赛A题</h1><h1 id="2023年全国大学生数学建模竞赛b题"><a class="markdownIt-Anchor" href="#2023年全国大学生数学建模竞赛b题"></a> 2023年全国大学生数学建模竞赛B题</h1><h1 id="2023年全国大学生数学建模竞赛c题"><a class="markdownIt-Anchor" href="#2023年全国大学生数学建模竞赛c题"></a> 2023年全国大学生数学建模竞赛C题</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python学习（更新中）</title>
      <link href="/2024/07/03/python%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
      <url>/2024/07/03/python%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分-基础函数"><a class="markdownIt-Anchor" href="#第一部分-基础函数"></a> 第一部分 基础函数</h1><h3 id="1print函数"><a class="markdownIt-Anchor" href="#1print函数"></a> 1.print函数</h3><p>1.0使用方式：<br />把要输出的内容放在()内。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">90</span>) <span class="comment"># 输出的是数字</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">50</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># 输出的是变量的值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(a+b) <span class="comment"># 输出的是运算结果</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;没有网络安全，就没有国家安全&#x27;</span>) <span class="comment"># 输出的是字符串</span></span><br><span class="line"><span class="comment"># 需要注意的是，字符串还可以放在&#x27;&#x27;&#x27;与&#x27;&#x27;&#x27;间，&quot;与&quot;间，&quot;&quot;&quot;与&quot;&quot;&quot;间。</span></span><br></pre></td></tr></table></figure><p><font color=red><strong>需要注意的是：代码段中可以有多个<em>print</em>函数，输出在屏幕上时每个<em>print</em>函数锁输出的内容占一行。</strong></font></p><p><em>1.1使用print函数一行输出多组数据：</em><br /><em>把要输出的内容用&quot;,&quot;隔开。</em><br /><em>例如：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">114514</span>,<span class="number">1919810</span>)</span><br></pre></td></tr></table></figure><p><em>输出结果：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">114514</span> <span class="number">1919810</span></span><br></pre></td></tr></table></figure><p><em>1.2使用print函数输出ASCII码对应字符</em><br /><em>用chr()包裹ASCII码。</em><br /><em>例如：要输出字符b。</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">98</span>))</span><br></pre></td></tr></table></figure><p><em>输出结果：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b</span><br></pre></td></tr></table></figure><p><em>1.3使用print函数输出中文Unicode码</em><br /><em>用ord(‘’)包裹中文字符。</em><br /><em>例如：要输出“北”的Unicode码。</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;北&#x27;</span>))</span><br></pre></td></tr></table></figure><p><em>输出结果：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21271</span></span><br></pre></td></tr></table></figure><p><em><font color=skyblue>T1.1：Unicode编码是在ASCII码上演化而来，所以可以用chr()将Unicode编码转换为中文字符。</font></em></p><p><em>1.4使用print函数将内容写入到文件</em><br /><em>step1:需要创建一个供写入的文件</em><br /><em>step2:将内容使用print函数写入到文件</em><br /><em>step3:关闭文件</em><br /><em>例如：输出“没有网络安全，就没有国家安全”到文本文档ChairmanXi.txt</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fp=<span class="built_in">open</span>(<span class="string">&#x27;ChairmanXi.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="comment"># open()函数--&gt;打开文件 w--&gt;文件操作类型：写入</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;没有网络安全，就没有国家安全&#x27;</span>,file=fp) <span class="comment"># 将内容写入到指定文件</span></span><br><span class="line">fp.close <span class="comment"># 关闭文件</span></span><br></pre></td></tr></table></figure><p><font color=skyblue><em>T1.2：文件操作类型一览表</em></font><br /><img src="https://s3.bmp.ovh/imgs/2024/07/28/0f7339ded191f509.png" alt="" /></p><p><em>1.5使用print函数进行复杂输出</em><br /><em>首先需要了解print函数完整的语法结构：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(value,...,sep=<span class="string">&#x27; &#x27;</span>,end=<span class="string">&#x27;\n&#x27;</span>,file=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><em>其中：</em><font color=lightgreen><br /><em>value：表示要输出的内容，可以是数字、字符串、变量等。</em><br /><em>sep=’ '：用于指定输出多个 value 时它们之间的分隔符。默认是空格，但可以设置为其他字符，例如逗号、分号等。</em><br /><em>end=‘\n’：用于指定输出内容的结尾字符。默认是换行符 \n，这意味着每次调用 print 函数后，输出都会换到下一行。可以将其设置为其他字符，例如空字符串 ‘’，这样输出就不会自动换行。</em><br /><em>file=None：用于指定输出的目标。默认情况下，print 函数输出到屏幕（即标准输出）。但也可以将其指定为一个文件对象，这样输出就会写入文件。</em></font><br /><em>例如：a.用两个print函数输出“专线–&gt;灵隐”</em></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;专线&#x27;</span>,end=<span class="string">&#x27;--&gt;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;灵隐&#x27;</span>)</span><br></pre></td></tr></table></figure><p><em>输出结果：</em></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">专线--&gt;灵隐</span><br><span class="line">           <span class="comment"># 这里会多出一个空行</span></span><br></pre></td></tr></table></figure><p><em>又或是：b.用一个print函数输出“专线”“–&gt;”“灵隐”</em></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;专线&#x27;</span>+<span class="string">&#x27;--&gt;&#x27;</span>+<span class="string">&#x27;灵隐&#x27;</span>) <span class="comment"># &quot;+&quot;为连接符，只能用于字符串连接。若不是，则需要用str()指令转换后连接。</span></span><br></pre></td></tr></table></figure><p><em>输出结果：</em></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">专线--&gt;灵隐</span><br></pre></td></tr></table></figure><h3 id="2input函数"><a class="markdownIt-Anchor" href="#2input函数"></a> 2.input函数</h3><p>2.0使用方式：<br />把要输入的内容放在()内。</p><p><font color=red><strong>注意：无论输入的数据是什么，其数据类型都为<em>字符串</em>类型。</strong></font></p><p><em>2.1使用input函数输入自己的姓名</em><br /><em>例如：</em></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;请输入你的姓名：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的姓名是：&#x27;</span>+name)</span><br></pre></td></tr></table></figure><p><em>运行后会出现如下窗口：</em><br /><img src="https://s3.bmp.ovh/imgs/2024/07/28/203b94bfc8e021d8.png" alt="" /><br /><em>此时我们需要键入我们的名字（当然也可以是别的信息，然后按下回车。</em><br /><img src="https://s3.bmp.ovh/imgs/2024/07/28/f7aa44ac34adcdcb.png" alt="" /></p><p><em>2.2使用input函数输入整数类型的数据</em><br /><em>使用int函数将输入内容转换为整数类型。</em></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num=<span class="built_in">input</span>(<span class="string">&#x27;请输入一个数字:&#x27;</span>)</span><br><span class="line"><span class="built_in">int</span>(num)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意：整数类型数据并不能与字符串类型一起输出，需要用逗号连接。</strong></font></p><h3 id="3注释"><a class="markdownIt-Anchor" href="#3注释"></a> 3.注释</h3><p>3.0使用方式：<br />把要注释的内容写在标记符后。注释可以提高代码的可读性。</p><p><em>3.1单行注释</em><br /><em>把注释内容写在#后面，例如：</em></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个注释</span></span><br></pre></td></tr></table></figure><p><em>3.2多行注释</em><br /><em>用两个```包裹的就是多行注释。本质：字符串。</em></p><p><em>3.3中文文档声明注释</em><br /><em><font color=red><strong>注意：一定要写在第一行！</strong></font></em></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># ↑中文文档声明注释要写在第一行</span></span><br></pre></td></tr></table></figure><h3 id="4代码缩进"><a class="markdownIt-Anchor" href="#4代码缩进"></a> 4.代码缩进</h3><p>4.0使用方法：<br />代码缩进是每行语句开始前的空白区域，用来表示语句间的包含和层次关系。通常使用4个空格作为1个缩进量。</p><p><em>4.1代码缩进的使用</em></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般代码 不需要缩进</span></span><br><span class="line"><span class="built_in">print</span>(hello)</span><br><span class="line"><span class="built_in">print</span>(world)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特殊情况 需要缩进</span></span><br><span class="line"><span class="comment"># 类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 换行自动缩进1缩进量</span></span><br><span class="line"><span class="comment"># 函数的定义</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 换行自动缩进1缩进量</span></span><br></pre></td></tr></table></figure><h1 id="第二部分-数据类型和运算符"><a class="markdownIt-Anchor" href="#第二部分-数据类型和运算符"></a> 第二部分 数据类型和运算符</h1><h3 id="1保留字keyword"><a class="markdownIt-Anchor" href="#1保留字keyword"></a> 1.保留字（keyword）</h3><p>1.0定义：<br />在python语言中被赋予特定意义的一些单词。在开发程序时，不可以将这些保留字（keyword）作为变量、函数、类、模块和其他对象的名称来使用。</p><p><em><font color=skyblue>T2.1：python中的保留字（keyword）</font></em></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">False</span>      <span class="keyword">await</span>      <span class="keyword">else</span>       <span class="keyword">import</span>     <span class="keyword">pass</span></span><br><span class="line"><span class="literal">None</span>       <span class="keyword">break</span>      <span class="keyword">except</span>     <span class="keyword">in</span>         <span class="keyword">raise</span></span><br><span class="line"><span class="literal">True</span>       <span class="keyword">class</span>      <span class="title class_">finally</span>    <span class="keyword">is</span>         <span class="keyword">return</span></span><br><span class="line"><span class="keyword">and</span>        <span class="keyword">continue</span>   <span class="keyword">for</span>        <span class="keyword">lambda</span>     <span class="keyword">try</span></span><br><span class="line"><span class="keyword">as</span>         <span class="keyword">def</span>        <span class="title function_">from</span>       <span class="keyword">nonlocal</span>   <span class="keyword">while</span></span><br><span class="line"><span class="keyword">assert</span>     <span class="keyword">del</span>        <span class="keyword">global</span>     <span class="keyword">not</span>        <span class="keyword">with</span></span><br><span class="line"><span class="keyword">async</span>      <span class="keyword">elif</span>       <span class="keyword">if</span>         <span class="keyword">or</span>         <span class="keyword">yield</span></span><br></pre></td></tr></table></figure><p><strong><font color=red>保留字（keyword）严格区分大小写！！！</font></strong></p><p><em>1.1查询python中的保留字（keyword）</em></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"><span class="built_in">print</span>(keyword.kwlist) <span class="comment"># 获得保留字（keyword）列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(keyword.kwlist)) <span class="comment"># 获取保留字（keyword）的个数</span></span><br></pre></td></tr></table></figure><h3 id="2标识符"><a class="markdownIt-Anchor" href="#2标识符"></a> 2.标识符</h3><p>2.0定义和命名规则<br />a.可以是字符（英文、中文）、下划线 “_” 和数字，并且第一个字符不能是数字。<br />b.不能使用Python中的保留字。<br />c.标识符严格区分大小写。<br />d.以下划线开头的标识符有特殊意义，一般应避免使用相似的标识符。<br />e.允许使用中文作为标识符，但不建议使用。</p><p><em><font color=skyblue>T2.2：python标识符的命名规范</em><br /><em>a.模块名尽量短小，并且全部使用小写字母，可以使用下划线分隔多个字母。例如: grame_main。</em><br /><em>b.包名尽量短小，并且全部使用小写字母，不推荐使用下划线。例如: com.ysjpython ，不推荐使用com_ysjpython。</em><br /><em>c.类名采用单词首字母大写形式(Pascal风格)。例如: MyClass。</em><br /><em>d.模块内部的类采用 “_” +Pascal 风格的类名组成，例如:在MyClass中的内部类_InnerMyClass。</em><br /><em>e.函数、类的属性和方法的命名，全部使用小写字母，多个字母之间使用下划线分隔。</em><br /><em>f.常量命名时采用全部大写字母，可以使用下划线。</em><br /><em>g.使用单下划线“<em>”开头的模块变量或函数是受保护的，在使用“from xxx import <em>”语句从模块中导入时，这些模块变量或函数不能被导入。</em><br />*h.使用双下划线“</em>__”开头的实例变量或方法是类私有的。</em><br /><em>i.以双下划线开头和结尾的是Python的专用标识，例如：<strong>init</strong>()表示初始化函数。</em></font></p>]]></content>
      
      
      <categories>
          
          <category> basic knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识储备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JPEG</title>
      <link href="/2024/07/01/JPEG/"/>
      <url>/2024/07/01/JPEG/</url>
      
        <content type="html"><![CDATA[<p><strong>一道题的引入</strong></p><blockquote><p>你知道一张JPEG图片是怎样炼成的吗？<br />灰度图像，8x8分块，DCT变化，接下来应该是？<br />将flag{}替换为NSSCTF{}后提交<br />hint：<a href="https://www.bilibili.com/video/BV1H2421F7sg/">https://www.bilibili.com/video/BV1H2421F7sg/</a></p></blockquote><p><em>-题目名称：JPEG是怎样炼成的-</em><br /><em>-题目来源：GHCTF 2024-</em></p>]]></content>
      
      
      <categories>
          
          <category> CTF study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP反序列化（更新中）</title>
      <link href="/2024/06/30/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
      <url>/2024/06/30/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>在PHP中，序列化和反序列化是两种常用的处理对象的方法。序列化是将对象转换成一个可以存储或传输的字符串的过程，而反序列化则是将这个字符串转换回原始对象的过程。</p><p>以下是在PHP中进行反序列化的基本步骤：</p><ol><li>序列化对象<br />首先，你需要有一个已经被序列化的对象。在PHP中，你可以使用<code>serialize()</code>函数来序列化一个对象。</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var1</span> = <span class="string">&#x27;value1&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var2</span> = <span class="string">&#x27;value2&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title class_">MyClass</span>();<span class="variable">$serializedObj</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$obj</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>存储序列化字符串<br />序列化后的字符串可以存储在文件、数据库或通过HTTP请求发送。</p></li><li><p>反序列化对象<br />当你需要使用这个对象时，可以使用<code>unserialize()</code>函数来反序列化字符串。</p></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$unserializedObj</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$serializedObj</span>);</span><br></pre></td></tr></table></figure><p>现在<code>$unserializedObj</code>是一个<code>MyClass</code>的实例，并且拥有原始对象的属性值。</p><p><strong>示例</strong><br />以下是一个完整的示例，展示了如何在PHP中序列化和反序列化对象：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var1</span> = <span class="string">&#x27;value1&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var2</span> = <span class="string">&#x27;value2&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个对象</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化对象</span></span><br><span class="line"><span class="variable">$serializedObj</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$obj</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们将序列化的字符串存储在某个地方，现在我们将其读取回来</span></span><br><span class="line"><span class="comment">// 在实际应用中，你可能从文件、数据库或网络中读取这个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化对象</span></span><br><span class="line"><span class="variable">$unserializedObj</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$serializedObj</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用反序列化后的对象</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$unserializedObj</span>-&gt;var1; <span class="comment">// 输出: value1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$unserializedObj</span>-&gt;var2; <span class="comment">// 输出: value2</span></span><br></pre></td></tr></table></figure><h1 id="类和对象"><a class="markdownIt-Anchor" href="#类和对象"></a> 类和对象</h1><h2 id="1类是什么"><a class="markdownIt-Anchor" href="#1类是什么"></a> 1.类是什么</h2><p>在PHP中，类（Class）是面向对象编程（OOP）的一个基本概念，它是创建对象（Object）的蓝图或者模板。类定义了一组属性（也称为成员变量）和方法（也称为成员函数），它们共同描述了一个对象的状态和行为。<br />以下是关于PHP中类的一些关键点：</p><h3 id="类的定义"><a class="markdownIt-Anchor" href="#类的定义"></a> 类的定义</h3><p>一个类通过<code>class</code>关键字来定义，后面跟着类的名称和一对花括号，其中包含类的属性和方法的定义。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$property1</span>;</span><br><span class="line">    <span class="comment">// 方法定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">myMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性properties"><a class="markdownIt-Anchor" href="#属性properties"></a> 属性（Properties）</h3><p>属性是类中定义的变量，它们用于存储数据。属性可以具有不同的访问修饰符，比如<code>public</code>、<code>protected</code>和<code>private</code>，这些修饰符决定了属性在类的外部是否可以被访问。</p><h3 id="方法methods"><a class="markdownIt-Anchor" href="#方法methods"></a> 方法（Methods）</h3><p>方法是类中定义的函数，它们用于执行操作。和属性一样，方法也可以有访问修饰符，并且可以接受参数和返回值。</p><h3 id="创建对象"><a class="markdownIt-Anchor" href="#创建对象"></a> 创建对象</h3><p>通过使用<code>new</code>关键字和类名，可以创建一个类的实例（即对象）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure><h3 id="访问属性和方法"><a class="markdownIt-Anchor" href="#访问属性和方法"></a> 访问属性和方法</h3><p>创建对象后，可以使用对象操作符<code>-&gt;</code>来访问对象的属性和方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$obj</span>-&gt;property1 = <span class="string">&quot;value1&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;property1; <span class="comment">// 输出: value1</span></span><br><span class="line"><span class="variable">$obj</span>-&gt;<span class="title function_ invoke__">myMethod</span>();    <span class="comment">// 调用对象的方法</span></span><br></pre></td></tr></table></figure><h3 id="构造函数和析构函数"><a class="markdownIt-Anchor" href="#构造函数和析构函数"></a> 构造函数和析构函数</h3><ul><li>构造函数<code>__construct()</code>在创建对象时自动调用，用于初始化对象。</li><li>析构函数<code>__destruct()</code>在对象被销毁时自动调用，用于执行清理工作。</li></ul><h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3><p>PHP支持继承，允许一个类继承另一个类（称为父类或基类）的属性和方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 继承MyClass的属性和方法，并可以添加新的或覆盖已有的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h3><p>封装是指将对象的实现细节隐藏起来，只暴露出必要的接口。在PHP中，通过定义属性和方法的访问修饰符来实现封装。</p><h3 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h3><p>多态是指同一个方法在不同类型的对象上有不同的行为。在PHP中，多态通常通过继承和接口来实现。</p><h3 id="静态属性和方法"><a class="markdownIt-Anchor" href="#静态属性和方法"></a> 静态属性和方法</h3><p>静态属性和方法属于类本身，而不是类的任何特定实例。它们可以通过类名直接访问，无需创建对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="variable">$staticProperty</span> = <span class="string">&quot;Static Property&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">staticMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Static Method&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title class_">MyClass</span>::<span class="variable">$staticProperty</span>; <span class="comment">// 输出: Static Property</span></span><br><span class="line"><span class="title class_">MyClass</span>::<span class="title function_ invoke__">staticMethod</span>();       <span class="comment">// 输出: Static Method</span></span><br></pre></td></tr></table></figure><p>PHP的类机制为开发者提供了强大的面向对象编程能力，是构建复杂数据结构和功能模块的基础。</p><h2 id="2对象是什么"><a class="markdownIt-Anchor" href="#2对象是什么"></a> 2.对象是什么</h2><p>在PHP中，对象是面向对象编程（OOP）的一个核心概念。一个对象是一个具体的数据实体，它是根据类的定义创建的。类（Class）可以视为一个模板或蓝图，而对象（Object）则是根据这个模板创建的实例。<br />以下是关于PHP中对象的一些关键点：</p><h3 id="对象的定义"><a class="markdownIt-Anchor" href="#对象的定义"></a> 对象的定义</h3><ul><li><strong>对象</strong>：是类的一个实例，它具有类定义中的属性（变量）和方法（函数）。</li></ul><h3 id="创建对象-2"><a class="markdownIt-Anchor" href="#创建对象-2"></a> 创建对象</h3><p>在PHP中，使用<code>new</code>关键字加上类名来创建一个对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$property</span> = <span class="string">&quot;I am a property!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">myMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;I am a method!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 创建一个MyClass类的实例</span></span><br></pre></td></tr></table></figure><h3 id="对象的属性"><a class="markdownIt-Anchor" href="#对象的属性"></a> 对象的属性</h3><p>对象的属性是存储在对象内部的变量，它们用于表示对象的状态。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="variable">$obj</span>-&gt;property; <span class="comment">// 输出：I am a property!</span></span><br></pre></td></tr></table></figure><h3 id="对象的方法"><a class="markdownIt-Anchor" href="#对象的方法"></a> 对象的方法</h3><p>对象的方法是存储在对象内部的函数，它们用于定义对象的行为。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$obj</span>-&gt;<span class="title function_ invoke__">myMethod</span>(); <span class="comment">// 输出：I am a method!</span></span><br></pre></td></tr></table></figure><h3 id="对象的特性"><a class="markdownIt-Anchor" href="#对象的特性"></a> 对象的特性</h3><ul><li><strong>封装</strong>：对象将数据（属性）和操作数据的方法（函数）封装在一起，外部只能通过对象公开的方法来访问和修改对象的状态。</li><li><strong>继承</strong>：对象可以继承另一个对象的属性和方法，子对象可以扩展或修改继承来的行为。</li><li><strong>多态</strong>：对象可以以不同的形式实现相同的方法，这意味着多个对象可以响应同一个消息，但以不同的方式执行。</li></ul><h3 id="对象的操作"><a class="markdownIt-Anchor" href="#对象的操作"></a> 对象的操作</h3><ul><li><strong>访问属性</strong>：使用<code>-&gt;</code>操作符来访问对象的属性。</li><li><strong>调用方法</strong>：使用<code>-&gt;</code>操作符来调用对象的方法。</li><li><strong>修改属性</strong>：可以直接给对象的属性赋值来修改它们。</li></ul><h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$age</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;name = <span class="variable">$name</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;age = <span class="variable">$age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">introduce</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;My name is &quot;</span> . <span class="variable language_">$this</span>-&gt;name . <span class="string">&quot; and I am &quot;</span> . <span class="variable language_">$this</span>-&gt;age . <span class="string">&quot; years old.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$person</span> = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>); <span class="comment">// 创建Person类的实例</span></span><br><span class="line"><span class="variable">$person</span>-&gt;<span class="title function_ invoke__">introduce</span>(); <span class="comment">// 调用对象的方法</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>$person</code>是一个对象，它是<code>Person</code>类的一个实例，具有<code>name</code>和<code>age</code>两个属性，以及<code>introduce</code>一个方法。<br />对象在PHP中的应用非常广泛，它们使得代码更加模块化、可重用和易于维护。通过使用对象，开发者可以构建出结构清晰、功能强大的应用程序。</p>]]></content>
      
      
      <categories>
          
          <category> CTF study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见RSA解密</title>
      <link href="/2024/06/04/%E5%B8%B8%E8%A7%81RSA%E8%A7%A3%E5%AF%86/"/>
      <url>/2024/06/04/%E5%B8%B8%E8%A7%81RSA%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="常见rsa解密脚本"><a class="markdownIt-Anchor" href="#常见rsa解密脚本"></a> 常见RSA解密脚本</h1><h2 id="1已知cnrpq"><a class="markdownIt-Anchor" href="#1已知cnrpq"></a> 1.已知c,n,r,p,q</h2><p>例题：[LitCTF2023]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">q = 189239861511125143212536989589123569301</span><br><span class="line">p = 386123125371923651191219869811293586459</span><br><span class="line"> </span><br><span class="line">e = 65537</span><br><span class="line">c = 28767758880940662779934612526152562406674613203406706867456395986985664083182</span><br><span class="line"></span><br><span class="line">n = q*p</span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e, (p - 1) * (q - 1))</span><br><span class="line">print(&quot;d=&quot;,d)</span><br><span class="line">m = pow(c, d, n)</span><br><span class="line">print(m)</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学</title>
      <link href="/2024/06/04/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
      <url>/2024/06/04/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="命题演算的基本规律"><a class="markdownIt-Anchor" href="#命题演算的基本规律"></a> 命题演算的基本规律</h1><h2 id="1命题的基本概念"><a class="markdownIt-Anchor" href="#1命题的基本概念"></a> 1.命题的基本概念</h2><h1 id="关系与映射"><a class="markdownIt-Anchor" href="#关系与映射"></a> 关系与映射</h1><h2 id="考点"><a class="markdownIt-Anchor" href="#考点"></a> 考点</h2><p>1.关系、映射、函数的概念</p><p>2.单射、满射、一一映射</p><p>3.集合的运算</p><h1 id="图"><a class="markdownIt-Anchor" href="#图"></a> 图</h1><p><strong>定义14.1</strong><br />无向图G = &lt;V,E&gt;, 其中：<br />(1) V ≠ ∅为顶点集，元素称为顶点<br />(2) E为V&amp;V 的多重集，其元素称为无向边，简称边<br /><strong>定义14.2</strong><br />有向图D=&lt;V,E&gt;, 只需注意E是V×V 的多重子集</p><p>图2表示的是一个有向图，试写出它的 V 和 E<br /><img src="https://ooo.0x0.ooo/2024/06/04/OJSa2a.png" alt="图2" /><br /><font color=orange>注意：图的数学定义与图形表示，在同构（待叙）的意义下是一一对应的</font></p>]]></content>
      
      
      <categories>
          
          <category> basic knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识储备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言</title>
      <link href="/2024/06/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
      <url>/2024/06/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="二-字符数据处理"><a class="markdownIt-Anchor" href="#二-字符数据处理"></a> 二、字符数据处理</h2><p>在应用程序的设计中，经常会遇到各种字符或字符串的处理。字符处理通常包括字符的比较、检索、插入、删除和统计等。</p><h3 id="1字符串比较"><a class="markdownIt-Anchor" href="#1字符串比较"></a> 1.字符串比较</h3><p><font color=green>例、在数据区BUF1和BUF2地址开始分别有一字符串，长度均为14字节。试比较这两个字符串，若相同，则给RES单元置0；若不同，则给RES单元置0FFH，并将失配字节地址送RES＋1开始的两个存储单元中。</font></p><p>源程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">DATA     SEGMENT</span><br><span class="line">BUF1      DB   &#x27;I am a student&#x27;</span><br><span class="line">BUF2      DB   &#x27;I am a studant&#x27;</span><br><span class="line">RES       DB   3  DUP (?)</span><br><span class="line">NUMBER  EQU  14</span><br><span class="line">DATA     ENDS</span><br><span class="line">STACK1   SEGMENT  PARA  STACK  &#x27;STACK&#x27;</span><br><span class="line">STA       DB   100  DUP (?)</span><br><span class="line">STACK1   ENDS</span><br><span class="line">CODE     SEGMENT</span><br><span class="line">          ASSUME  CS: CODE, DS: DATA, ES:DATA, SS: STACK1</span><br><span class="line">START：   MOVAX, DATA</span><br><span class="line">          MOVDS, AX</span><br><span class="line">          MOVES, AX</span><br><span class="line">    LEABX, RES</span><br><span class="line">          LEASI, BUF1</span><br><span class="line">          LEADI, BUF2</span><br><span class="line">          MOVCX, NUMBER</span><br><span class="line">          CLD</span><br><span class="line">          REPE CMPSB          </span><br><span class="line">            JNZUNSAME</span><br><span class="line">    MOVAX, 0</span><br><span class="line">    MOV[BX], AL</span><br><span class="line">    MOVDL, [BX] </span><br><span class="line">      JMPOVER</span><br><span class="line">UNSAME： MOVAX, 0FFH</span><br><span class="line">    MOV[BX], AL</span><br><span class="line">          INCBX</span><br><span class="line">    DECDI</span><br><span class="line">    MOV[BX], DI</span><br><span class="line">OVER：    MOV AH, 4CH           </span><br><span class="line">            INT21H</span><br><span class="line">CODE     ENDS</span><br><span class="line">          ENDSTART</span><br></pre></td></tr></table></figure><h3 id="2字符串检索"><a class="markdownIt-Anchor" href="#2字符串检索"></a> 2.字符串检索</h3><p>字符串检索就是在一个字符串中寻找一些关键字符或关键字符（串）。<br /><font color=green>例、在内存数据区有一数据块，首地址BUF，长度为50字节。检索其中是否有与内存单元KEYWORD中相同的字符。若有则记录第一个遇到的关键字地址；若无则DI赋0。</font></p><p>源程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">KEYWORD DB   50H</span><br><span class="line">BUF      DB   20H, 34H, 98H, 78H, ……</span><br><span class="line">RES    DW   ？</span><br><span class="line">DATA     ENDS</span><br><span class="line">STACK1   SEGMENT  PARA  STACK  ‘STACK’</span><br><span class="line">STA       DB   100  DUP (?)</span><br><span class="line">STACK1   ENDS</span><br><span class="line">CODE     SEGMENT</span><br><span class="line">     ASSUME  CS: CODE, DS: DATA, ES: DATA, SS:STACK1</span><br><span class="line">START：   MOVAX, DATA</span><br><span class="line">          MOVDS, AX</span><br><span class="line">        MOVES, AX</span><br><span class="line">    MOVAL, KEYWORD</span><br><span class="line">        LEADI, BUF</span><br><span class="line">      MOVCX, 50</span><br><span class="line">      CLD</span><br><span class="line">     REPNE  SCASB           ；重复搜索</span><br><span class="line">      JZFOUND</span><br><span class="line">    MOVDI, 0</span><br><span class="line">        JMPOVER</span><br><span class="line">FOUND：  DECDI</span><br><span class="line">    MOVRES, DI      ；送第一个遇到的关键字地址</span><br><span class="line">OVER：  MOVAH, 4CH </span><br><span class="line">         INT21H</span><br><span class="line">CODE     ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure><h3 id="3字符插入与删除"><a class="markdownIt-Anchor" href="#3字符插入与删除"></a> 3.字符插入与删除</h3><p>字符的插入和删除是字符运用的主要形式。</p><h4 id="1-字符插入"><a class="markdownIt-Anchor" href="#1-字符插入"></a> 1） 字符插入</h4><p><font color=green>例、假设从BUF1地址开始有一个长度为100的字符串，串长度存于LONG单元。现要求在第一个“E”字符后插入一个字符串，其长度6。该字串存于BUF2单元开始的存储区中。若进行插入，SIGN单元置1，否则置0。</font></p><p>源程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">DATASEGMENT</span><br><span class="line">LONG      DB   100</span><br><span class="line">BUF1DB   &#x27;ABCDEFGADE……&#x27;</span><br><span class="line">FREEDOMDB  6  DUP (?)</span><br><span class="line">BUF2      DB   ‘INSERT’</span><br><span class="line">SIGN      DB   ？</span><br><span class="line">DATA     ENDS</span><br><span class="line">STACK1    SEGMENT  PARA  STACK  &#x27;STACK&#x27;</span><br><span class="line">            STADB   100  DUP (?)</span><br><span class="line">STACK1   ENDS</span><br><span class="line">CODE     SEGMENT</span><br><span class="line">          ASSUME  CS: CODE, DS: DATA, ES: DATA, SS: STACK1</span><br><span class="line">START：   MOVAX, DATA</span><br><span class="line">          MOVDS, AX</span><br><span class="line">          MOVES, AX</span><br><span class="line">    MOVCL, LONG</span><br><span class="line">          LEA DI, BUF1</span><br><span class="line">          MOVAL, &#x27;E&#x27;</span><br><span class="line">          CLD</span><br><span class="line">          REPNE SCASB          </span><br><span class="line">            JZFOUND</span><br><span class="line">    MOVSIGN, 0</span><br><span class="line">          JMPOVER</span><br><span class="line">FOUND：  MOVSI, OFFSETFREEDOM－1</span><br><span class="line">          MOVDI, OFFSETFREEDOM＋5</span><br><span class="line">         STD </span><br><span class="line">          REPMOVSB</span><br><span class="line">            LEA SI, BUF2＋5</span><br><span class="line">    MOV CX, 6</span><br><span class="line">    STD</span><br><span class="line">    REPMOVSB</span><br><span class="line">    MOVSIGN, 1</span><br><span class="line">OVER：   MOVAH, 4CH</span><br><span class="line">          INT21H</span><br><span class="line">CODE    ENDS</span><br><span class="line">        ENDSTART</span><br></pre></td></tr></table></figure><h4 id="2字符删除"><a class="markdownIt-Anchor" href="#2字符删除"></a> 2）字符删除</h4><p><font color=green>例、假设从BUF地址开始有一个字符串，串长度存于LONG单元。现要求删除所有的“D”字符并要求修改字符长度并存入LONG单元中。</font></p><p>源程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">DATASEGMENT</span><br><span class="line">LONG      DB   100</span><br><span class="line">BUF      DB   &#x27;ABCDEFGADE……&#x27;</span><br><span class="line">DATA     ENDS</span><br><span class="line">STACK1   SEGMENT  PARA  STACK  &#x27;STACK&#x27;</span><br><span class="line">STA       DB   100  DUP (?)</span><br><span class="line">STACK1   ENDS</span><br><span class="line">CODE     SEGMENT</span><br><span class="line">     ASSUME  CS: CODE, DS: DATA, ES: DATA, SS:STACK1</span><br><span class="line">START：   MOVAX, DATA</span><br><span class="line">          MOVDS, AX</span><br><span class="line">          MOVES, AX</span><br><span class="line">    MOVCL, LONG</span><br><span class="line">          LEADI, BUF</span><br><span class="line">          MOVBL, CL</span><br><span class="line">            MOVAL, ‘D’</span><br><span class="line">NEXT：    CLD</span><br><span class="line">          REPNE SCASB </span><br><span class="line">          JZFOUND</span><br><span class="line">          JMPOVER</span><br><span class="line">FOUND：  MOVSI, DI </span><br><span class="line">          DECDI</span><br><span class="line">          PUSH DI </span><br><span class="line">            PUSH CX </span><br><span class="line">            CLD</span><br><span class="line">          REPMOVSB</span><br><span class="line">    DECBL</span><br><span class="line">    POPCX</span><br><span class="line">    POPDI</span><br><span class="line">    JMPNEXT</span><br><span class="line">OVER：     MOVLONG, BL</span><br><span class="line">    MOVAH, 4CH</span><br><span class="line">          INT21H</span><br><span class="line">CODE     ENDS</span><br><span class="line">        ENDSTART</span><br></pre></td></tr></table></figure><h3 id="4字符统计"><a class="markdownIt-Anchor" href="#4字符统计"></a> 4.字符统计</h3><p><font color=green>例、在数据区STRING地址开始存有一字符串，以“$”作为结尾标志，长度不超过250个字节。统计该字符串的长度，并存于LENG单元中。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">源程序：</span><br><span class="line">DATASEGMENT</span><br><span class="line">STRING    DB   &#x27;ABCDEFGHIJKLM……&#x27;</span><br><span class="line">LENG      DB   ? </span><br><span class="line">DATA     ENDS</span><br><span class="line">STACK1   SEGMENT  PARA  STACK  &#x27;STACK&#x27;</span><br><span class="line">STA       DB   100  DUP (?)</span><br><span class="line">STACK1   ENDS</span><br><span class="line">CODE     SEGMENT</span><br><span class="line">          ASSUME  CS: CODE, DS: DATA, SS: STACK1</span><br><span class="line">START：     MOV AX, DATA</span><br><span class="line">          MOVDS, AX       </span><br><span class="line">MOVCX, 0</span><br><span class="line">          LEADI, STRING</span><br><span class="line">          MOVAL, &#x27;$&#x27;</span><br><span class="line">NEXT：      CMP AL, [DI]</span><br><span class="line">          JZOVER</span><br><span class="line">          INCDI</span><br><span class="line">          INCCX</span><br><span class="line">          JMPNEXT</span><br><span class="line">OVER：      MOVLENG, CL </span><br><span class="line">MOVAH, 4CH</span><br><span class="line">          INT21H</span><br><span class="line">CODE     ENDS</span><br><span class="line">        END START</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三表处理"><a class="markdownIt-Anchor" href="#三表处理"></a> 三.表处理</h1><p>表的应用很广泛，如有平方表、转移表、换码表等。表中可以存放一系列供机器执行的任务、一系列相关联的数据及执行结果，以供在各种情况下使用。</p><h3 id="1表查询"><a class="markdownIt-Anchor" href="#1表查询"></a> 1）表查询</h3><p>表查询有直接表查询、顺序表查询、折半表查询和散列值表查询等。</p><p>直接表查询是查询的内容正是表内要查项的地址，因而不用比较，直接取该地址的内容。如果该地址内容为非空则查找成功，否则为查找失败。这种查表法查找速度快，但要求表中各项内容是连续有序的。所以在设计表格时，应尽量满足这个要求。</p><h1 id="四检索"><a class="markdownIt-Anchor" href="#四检索"></a> 四.检索</h1><p>检索是在计算机数据处理中，特别是管理软件中经常使用的一种操作。检索就是在一组数据中寻找出需要的数据项。检索的过程，就是在数据组中找出具有给定关键字的过程。当找到时，称为检索成功；找不到，称检索失败。</p><p>实际使用的数据项，通常是一个记录，它包含有多个数据项。关键字不过只占用其中的一个或几个域。它能唯一地将各记录区别开。一般来说，无论哪个方面的检索系统，其信息量都是很大的。所以检索过程是很费时间的，所以检索算法的优劣将直接影响检索的速度。</p><h3 id="1顺序检索"><a class="markdownIt-Anchor" href="#1顺序检索"></a> 1）顺序检索</h3><p>顺序检索是一种简单的检索方法。这种检索方法是使用给出的关键字与数据序列中的各项关键字逐个进行比较，直到整个数据序列结尾。如果找到则检索成功，否则检索失败。</p><p>顺序检索常用来对无序数据序列进行检索。因为无序序列中关键字的排列没有任何规律，所以，必须从头开始逐一向后检索，以获得所要检索的项。</p><h3 id="2折半检索"><a class="markdownIt-Anchor" href="#2折半检索"></a> 2）折半检索</h3><p>折半检索也称二分检索，主要用于对已排序好的数据序列进行检索。其检索过程大致如下：设有一升序数据序列，首先用要检索的关键字与该数据序列的中间一项进行比较，如果相等则检索成功；如果不等则判断关键字是否小于中间项值，若小于则要查找的项位于数据序列前半部分，否则在后半部分。然后再在可能含有关键字的部分中间取一项与关键字比较，相等则检索成功，不等则重复上述操作，直至整个数据序列检索完毕。由于这种检索方法每次都将范围缩小一半，故称折半检索。</p><p><font color=orange>折半检索完成一次成功的查找平均进行的比较次数为log<sub>2</sub>－1。</font>显然要比顺序检索法速度快得多。</p><p>在折半检索中，确定中间项是关键。下面讨论中间项的确定方法。</p><p>设一个数据序列包含N个数据，其第一个数据为下限数据，序号为1，用下限序号指针L表示。最后一个数据为上限数据，序号为N，用上限序号指针H表示。中间项数据序号M则可以由公式M＝INT[(L＋H)/2]得到。其中INT表示取整操作。当关键字与中间项比较之后，如果关键字包含在前半部分，则上限指针改为H＝M－1，下限指针不变。如果关键字包含在后半部分，则上限指针不变，下限指针改为H＝M＋1。然后再根据上、下限的指针确定新的中间项。如此不断地确定中间项与关键字进行比较，直到找到或确知无此关键字为止。此时L＞H。</p><p><font color=green>例、在数据区BUF地址起有一组升序数据，长度为10字节。KEYWORD单元中为已知关键字。检索其在数据序列中的序号。若检索成功，序号送RESULT单元，否则RESULT单元置0FFH。</font></p><p>源程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">DATASEGMENT</span><br><span class="line">BUFDB09H, 23H, 45H, 68H, 90H</span><br><span class="line">DB0A0H, 0ABH, 0C8H, 0D7H, 0F8H</span><br><span class="line">NDB10</span><br><span class="line">KEYWORDDB90H</span><br><span class="line">RESULTDW？</span><br><span class="line">DATAENDS</span><br><span class="line">STACK1SEGMENT  PARA  STACK  &#x27;STACK&#x27;</span><br><span class="line">STADB   100  DUP (?)</span><br><span class="line">STACK1ENDS</span><br><span class="line">CODESEGMENT</span><br><span class="line">ASSUME  CS: CODE, DS: DATA, SS; STACK1</span><br><span class="line">START： MOV AX, DATA</span><br><span class="line">        MOVDS, AX</span><br><span class="line">MOVBL, 1；置下限指针</span><br><span class="line">MOVBH, N；置上限指针</span><br><span class="line">LEADI, BUF</span><br><span class="line">        MOVCL, KEYWORD</span><br><span class="line">NEXT：   MOVAH, 0</span><br><span class="line">        MOVAL, BH；取上限指针值</span><br><span class="line">        ADDAL, BL；取下限指针值</span><br><span class="line">        SHRAL, 1；取中间项</span><br><span class="line">        MOVCH, AL；暂存中间项</span><br><span class="line">        ADDAX, DI；取中间项地址</span><br><span class="line">        MOVSI, AX</span><br><span class="line">        CMPCL, [SI]；与关键字比较</span><br><span class="line">        JZFOUND；找到，转FOUND</span><br><span class="line">MOVAL, CH；取回中间值</span><br><span class="line">        JABIG；高转BIG</span><br><span class="line">        DECCH；低于，修改上限指针</span><br><span class="line">        MOVBH, CH</span><br><span class="line">        JMPLOW</span><br><span class="line">BIG：    INCCH；高于，修改下限指针</span><br><span class="line">        MOVBL, CH</span><br><span class="line">LOW：   CMPBL, BH；比较上下限指针</span><br><span class="line">        JAOVER；下限指针大于上限指针，转结束</span><br><span class="line">        MPNEXT；继续检索</span><br><span class="line">FOUND：  MOVRESULT, CH</span><br><span class="line">JMPOVER1</span><br><span class="line">OVER：   MOVRESULT, 0FFH</span><br><span class="line">OVER1：  MOVAH, 4CH</span><br><span class="line">INT21H</span><br><span class="line">CODE     ENDS</span><br><span class="line">    ENDSTART</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="五排序"><a class="markdownIt-Anchor" href="#五排序"></a> 五.排序</h1><p>排序，是指对给定的一组元素，按规定的顺序进行排列。排序的目的就是为了检索提供方便。排序的方法很多，有交换排序、选择排序、插入排序、快速排序等。</p><p><font color=orange>常用思想：冒泡排序（“小数往上浮，大数往下沉”）</font></p><p><font color=green>例、在内存BUF单元开始的区域中存放有一组无符号的字节数据，试编程序将这些数据按从小到大的顺序排序，排序后的数据依然放在原来的存储区中。</font></p><p><font color=greee>具体算法是：首先在一组数中进行第一轮比较，将第一个存储单元中的数与其后的N－1个数进行比较，若两个数不满足降序排列，则将两者交换，即总是将两数中较大者放在第一存储单元中。这样经过N－1次比较后，N个数中最大数就存入到第一个单元中，其中N－1次比较可以用计数型循环来控制；接着进行第二轮比较，将第二个存储单元中的数与其后的N－2个存储单元中的数依次进行比较，不满足降序则交换。这样经过N－2次比较后，N个数中的次大者就存入第二个存储单元中，……，如此重复下去，直到第N－l轮比较完成后，将N个数中的第（N－1）大者存入第N－1个存储单元中，剩下第N个存储单元中的数自然是最小者。这样经过N－1轮比较就可以实现N个数的降序排序，从第一轮到第N－1轮的控制又可以用一个计数型循环来实现。这样整个程序就要用到双重循环来控制实现，其中，外循环是用来控制是第几轮比较，内循环是用来控制每一轮中比较的次数。</font></p><p>源程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DATASEGMENT</span><br><span class="line">BUFDB34H, 4BH, 22H, 1AH, 53H, 5DH</span><br><span class="line">N  EQU $-BUF    </span><br><span class="line">DATA  ENDS</span><br><span class="line">CODESEGMENT</span><br><span class="line">    ASSUME  CS: CODE, DS: DATA</span><br><span class="line">BEGIN:MOVAX, DATA</span><br><span class="line">      MOVDS, AX      </span><br><span class="line"> MOVSI, 1</span><br><span class="line">L1:MOVDI, SI</span><br><span class="line">    INC DI</span><br><span class="line">    MOV AL, [BUF＋SI－1]</span><br><span class="line">L2:CMP AL, [BUF＋DI－1]</span><br><span class="line">      JAE L3</span><br><span class="line">      XCHG [BUF＋DI－1], AL</span><br><span class="line">      MOV [BUF＋SI－1], AL</span><br><span class="line">L3:INC DI</span><br><span class="line">       CMPDI, N</span><br><span class="line">       JBEL2</span><br><span class="line">       INC SI </span><br><span class="line">CMPSI, N－1</span><br><span class="line">       JBE L1</span><br><span class="line">       MOV AH, 4CH</span><br><span class="line">       INT 21H</span><br><span class="line">CODE  ENDS</span><br><span class="line">       ENDBEGIN</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> basic knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识储备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GHCTF2024-WP</title>
      <link href="/2024/03/09/GHCTF2024-WP/"/>
      <url>/2024/03/09/GHCTF2024-WP/</url>
      
        <content type="html"><![CDATA[<h1 id="ghctf2024-wp"><a class="markdownIt-Anchor" href="#ghctf2024-wp"></a> GHCTF2024-WP</h1><h2 id="基本信息"><a class="markdownIt-Anchor" href="#基本信息"></a> 基本信息</h2><p>队伍名：Girls CTF Party<br />队伍成员：刘云飞（2023 级） 卜令问（2023 级） 翁崇峻（2023 级）</p><h2 id="web"><a class="markdownIt-Anchor" href="#web"></a> WEB</h2><h3 id="sign-in"><a class="markdownIt-Anchor" href="#sign-in"></a> Sign in</h3><p><em>解题： 卜令问</em><br /><img src="https://s3.bmp.ovh/imgs/2024/06/03/ca922c48223a69cd.png" alt="" /><br />打开题目发现是小恐龙，好像自己高中闲着无聊经常玩。 题目叫我们达到 1000000000 分去获得 flag。<br /><img src="https://s3.bmp.ovh/imgs/2024/06/03/25a49058ce875c5e.png" alt="" /><br />这种类型的题目，我第一反应是看源码。</p><p>发现只要 100000 就会给出一个奇怪的东西。<br /><img src="https://s3.bmp.ovh/imgs/2024/06/03/ddceed29f2dcf609.png" alt="" /><br />这串好像 base64 啊，把这串奇怪的东西拿去解码。 得到 flag。<br /><img src="https://s3.bmp.ovh/imgs/2024/06/03/872e12d17f5f4261.png" alt="" /></p><p>这里贴一篇青少年 ctf 的博客，我最早是从这里得到启发的：<a href="http://t.csdnimg.cn/UZ1Pm">http://t.csdnimg.cn/UZ1Pm</a></p><h2 id="pwn"><a class="markdownIt-Anchor" href="#pwn"></a> PWN</h2><h3 id="helloworld"><a class="markdownIt-Anchor" href="#helloworld"></a> Helloworld</h3><p><em>解题：翁崇峻</em></p><p>1.在 kali 终端中打开题目</p><p>2.ls  查看详细内容  3.cat 一下 flag ，over</p><p><img src="https://s3.bmp.ovh/imgs/2024/06/03/1d7e66c50bde6091.png" alt="" /></p><h2 id="reverse"><a class="markdownIt-Anchor" href="#reverse"></a> REVERSE</h2><h3 id="cs16"><a class="markdownIt-Anchor" href="#cs16"></a> CS1.6</h3><p><em>解题：刘云飞</em></p><p>拿到附件放入 die 查看</p><p><img src="https://s3.bmp.ovh/imgs/2024/06/03/9afc5e325a8c5253.png" alt="" /><br />题目提示 C#<br />放入 ILSPY<br /><img src="https://s3.bmp.ovh/imgs/2024/06/03/ce33719082836916.png" alt="" /><br />找到源代码</p><p><a href="https://postimg.cc/Sn2XhFqq"><img src="https://i.postimg.cc/nhTqqpPs/image.png" alt="image.png" /></a><br />根据源代码写出逆向脚本<br /><a href="https://postimg.cc/9rvmy455"><img src="https://i.postimg.cc/8zC7QWZ5/image.png" alt="image.png" /></a><br />解出 flag</p><h3 id="s"><a class="markdownIt-Anchor" href="#s"></a> .?.s.?</h3><p><em>解题：刘云飞</em></p><p>下载附件直接打开</p><p>根据代码写解密脚本</p><p>得到 flag</p><h3 id="ezam"><a class="markdownIt-Anchor" href="#ezam"></a> ezam</h3><p><em>解题：刘云飞</em></p><p>拿到附件 拖入 die 查看</p><p>发现打包工具为 PyInstaller</p><p>使用 pyinstxtractor 进行解包得到</p><p>将 ezam.pyc 拖入 python 解包工具网站中</p><p>下载源代码</p><p>得到了迷宫地图</p><p>发现是简单的 wads 移动 手动走迷宫 记录键盘得到 flag。</p><h2 id="crypto"><a class="markdownIt-Anchor" href="#crypto"></a> CRYPTO</h2><h3 id="crypto1921"><a class="markdownIt-Anchor" href="#crypto1921"></a> Crypto1921</h3><p><em>解题： 卜令问</em></p><p>打开附件，发现里面还有一个 zip。好奇点进去，发现加密了。 先不管，看看没加密的 code.txt 里有什么东西。</p><p>打开发现是摩斯电码。拿去解密=_=</p><p>解密后发现是中文电码，再解密。</p><p>全文附上：子卿兄法租借望志路幺洞六号疑似有马列分子请前去探查坐标东经幺二幺度二八 分幺六秒北纬三幺度幺三分六秒</p><p>然后根据电文里面的经纬度得到密码，进而得到电文。</p><p>再逆推刚才的思路就 OK 了</p><h3 id="2023-四省联考"><a class="markdownIt-Anchor" href="#2023-四省联考"></a> 2023 四省联考</h3><p><em>解题： 卜令问</em></p><p>打开附件，第一眼就看到了 hint。</p><p>不难知道，这题出的是椭圆曲线加密。没做过这类题，这下没头绪了，怎么办？万能的 csdn 来帮忙。</p><p>搜索后发现 hgame2022 有道题 ECC 好像有点类似（哪是类似，简直一毛一样）。 又发现 zip 里面有个 sage 文件，那直接开起来看看。</p><p>根据前辈的思路，再和 out.txt 结合，写脚本。</p><p>得到两个十六进制数。</p><p>再拿去化一下就得到了 flag。</p><h2 id="misc"><a class="markdownIt-Anchor" href="#misc"></a> MISC</h2><p><strong>real_signin</strong><br /><em>解题：刘云飞</em></p><p>password is md5((宫廷玉液酒 - (白云 -  黑土) *  小锤) ^  群英荟萃) 宫廷玉液酒 180  白云 71  黑土 75  小锤 40  群英荟萃 80</p><p>进行简单计算转化为 md5 得到 flag</p><p><strong>【Minecraft】还是</strong> <strong>ctf 大佬</strong></p><p><em>解题： 卜令问（游戏内密文）、刘云飞（游戏环境密钥）</em><br />以下是刘云飞的 wp：</p><p>打开文件夹发现 leve.dat 修改时间有问题 使用 bandzip  打开后再以文本形式打开里面的文 件 拉到最下面看到</p><p>得到 fakeFlagBut    flag{Y0u’r3_CTF_dAL4o!_06375f38}</p><p>以下是卜令问的 wp：</p><p>云飞去找密钥了，那我找密文吧</p><p>先把这个地图放到游戏根目录下面，然后开游戏进地图。</p><p>从发射器得到僵尸刷怪 damn。</p><p>再从火柴盒门口得到浆果。</p><p>利用铁砧提取出两端代码，进行结合。 得到：</p><p>U2FsdGVkX18IvcU3o3yy2+ISUlBY9rPbaxxonSVsO0lhvkBoGbyQAj/m4ZujleTTQSQn+Y+CZlHC99Wg AqasTg==</p><p>明显的 base64 格式。但是 hint:AES with salt     hint ：U2FsdGVkX 是重要特征。</p><p>对称式加密啊。。。</p><p>去找个工具解一下。</p><p>得到 flag</p><h2 id="eth"><a class="markdownIt-Anchor" href="#eth"></a> ETH</h2><p><strong>其疾如风</strong></p><p><em>解题： 卜令问</em></p><p>打开附件，发现是一个没有定位符的二维码</p><p>那就手动添加上去吧</p><p>扫码得到一串貌似是钱包地址的东西：</p><p>ethereum:0x57F1b45c28eDaC71d0A9Ffb54B7d8d2733E8d599 那不妨去看看。</p><p>目光很快锁定再交易记录上面 果不其然就在里面。</p><h2 id="iot"><a class="markdownIt-Anchor" href="#iot"></a> IOT</h2>]]></content>
      
      
      <categories>
          
          <category> CTF WP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
