<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>网络空间安全数学基础复习 | Astronomia001's blog</title><meta name="author" content="Astronomia001"><meta name="copyright" content="Astronomia001"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="定义：群、子群；陪集；除环；环同态；本原元；群同态；循环群；理想；整环；域。 群 (Group)：一个群是一个集合G和其上的一个二元运算·，满足以下四个性质：  封闭性：对于所有a, b ∈ G，有a · b ∈ G。 结合性：对于所有a, b, c ∈ G，有(a · b) · c &#x3D; a · (b · c)。 存在单位元：存在一个元素e ∈ G，使得对于所有a ∈ G，有e · a &#x3D; a">
<meta property="og:type" content="article">
<meta property="og:title" content="网络空间安全数学基础复习">
<meta property="og:url" content="http://astronomia001.github.io/2025/01/01/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Astronomia001&#39;s blog">
<meta property="og:description" content="定义：群、子群；陪集；除环；环同态；本原元；群同态；循环群；理想；整环；域。 群 (Group)：一个群是一个集合G和其上的一个二元运算·，满足以下四个性质：  封闭性：对于所有a, b ∈ G，有a · b ∈ G。 结合性：对于所有a, b, c ∈ G，有(a · b) · c &#x3D; a · (b · c)。 存在单位元：存在一个元素e ∈ G，使得对于所有a ∈ G，有e · a &#x3D; a">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2024/10/12/ab3f0e20e95418fd.jpg">
<meta property="article:published_time" content="2025-01-01T11:36:14.000Z">
<meta property="article:modified_time" content="2025-01-01T13:43:40.472Z">
<meta property="article:author" content="Astronomia001">
<meta property="article:tag" content="基础知识储备">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2024/10/12/ab3f0e20e95418fd.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://astronomia001.github.io/2025/01/01/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络空间安全数学基础复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-01 21:43:40'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s3.bmp.ovh/imgs/2024/10/12/ab3f0e20e95418fd.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Astronomia001's blog"><span class="site-name">Astronomia001's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">网络空间安全数学基础复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-01T11:36:14.000Z" title="发表于 2025-01-01 19:36:14">2025-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-01T13:43:40.472Z" title="更新于 2025-01-01 21:43:40">2025-01-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/basic-knowledge/">basic knowledge</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="网络空间安全数学基础复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image: url(/null)"></div><article class="post-content" id="article-container"><h3 id="定义群-子群陪集除环环同态本原元群同态循环群理想整环域"><a class="markdownIt-Anchor" href="#定义群-子群陪集除环环同态本原元群同态循环群理想整环域"></a> 定义：群、子群；陪集；除环；环同态；本原元；群同态；循环群；理想；整环；域。</h3>
<p><strong>群 (Group)</strong>：一个群是一个集合G和其上的一个二元运算·，满足以下四个性质：</p>
<ol>
<li>封闭性：对于所有a, b ∈ G，有a · b ∈ G。</li>
<li>结合性：对于所有a, b, c ∈ G，有(a · b) · c = a · (b · c)。</li>
<li>存在单位元：存在一个元素e ∈ G，使得对于所有a ∈ G，有e · a = a · e = a。</li>
<li>存在逆元：对于每个a ∈ G，存在一个元素b ∈ G，使得a · b = b · a = e。</li>
</ol>
<p><strong>子群 (Subgroup)</strong>：如果H是群G的一个非空子集，并且H关于G的运算也构成一个群，则称H是G的子群。</p>
<p><strong>陪集 (Coset)</strong>：给定群G和它的一个子群H，对于G中的任意元素a，集合aH = {ah | h ∈ H}称为H的一个左陪集。类似地，可以定义右陪集。</p>
<p><strong>除环 (Division Ring)</strong>：一个非交换的环，其中每个非零元素都有一个乘法逆元。</p>
<p><strong>环同态 (Ring Homomorphism)</strong>：从环R到环S的一个映射φ，满足对于所有a, b ∈ R，有φ(a + b) = φ(a) + φ(b)和φ(a · b) = φ(a) · φ(b)。</p>
<p><strong>本原元 (Primitive Element)</strong>：在域扩张L/K中，如果存在一个元素α ∈ L，使得L = K(α)，则称α是L/K的一个本原元。</p>
<p><strong>群同态 (Group Homomorphism)</strong>：从群G到群H的一个映射φ，满足对于所有a, b ∈ G，有φ(a · b) = φ(a) · φ(b)。</p>
<p><strong>循环群 (Cyclic Group)</strong>：如果群G可以由一个元素g生成，即G = ⟨g⟩ = {g^n | n ∈ Z}，则称G是循环群。</p>
<p><strong>理想 (Ideal)</strong>：环R的一个非空子集I，如果对于所有r ∈ R和所有a ∈ I，有r · a ∈ I和a · r ∈ I，则称I是R的一个理想。</p>
<p><strong>整环 (Integral Domain)</strong>：一个没有零因子的交换环。</p>
<p><strong>域 (Field)</strong>：一个交换除环，即每个非零元素都有一个乘法逆元。</p>
<h3 id="最小公倍数-a-b-与最大公因数-a-b-之间的关系"><a class="markdownIt-Anchor" href="#最小公倍数-a-b-与最大公因数-a-b-之间的关系"></a> 最小公倍数 [a, b] 与最大公因数 (a, b) 之间的关系：</h3>
<p>对于任意两个整数a和b，它们的最小公倍数[a, b]和最大公因数(a, b)之间有以下关系：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a * b = (a, b) * [a, b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span></p>
<h3 id="对称群"><a class="markdownIt-Anchor" href="#对称群"></a> 对称群</h3>
<p>对称群 $ S_n $ 的阶是 $ n $ 个元素的所有排列的数量，即 $ n! <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（</mtext></mrow><annotation encoding="application/x-tex">（</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span></span></span></span> n $ 的阶乘）。以下是 $ S_3 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，</mtext></mrow><annotation encoding="application/x-tex">，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span></span></span></span> S_4 $，和 $ S_6 $ 的阶：</p>
<ul>
<li>$ S_3 $ 的阶是 $ 3! = 6 $</li>
<li>$ S_4 $ 的阶是 $ 4! = 24 $</li>
<li>$ S_6 $ 的阶是 $ 6! = 720 $</li>
</ul>
<p>特别是对于 $ S_3 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，其元素可以列举如下，并且它们的交换性也会被讨论：</mtext></mrow><annotation encoding="application/x-tex">，其元素可以列举如下，并且它们的交换性也会被讨论：
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">举</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">交</span><span class="mord cjk_fallback">换</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">也</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">被</span><span class="mord cjk_fallback">讨</span><span class="mord cjk_fallback">论</span><span class="mord cjk_fallback">：</span></span></span></span> S_3 $ 的元素包括：</p>
<ol>
<li>恒等置换 $ e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（不做任何改变）：</mtext></mrow><annotation encoding="application/x-tex">（不做任何改变）：</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">做</span><span class="mord cjk_fallback">任</span><span class="mord cjk_fallback">何</span><span class="mord cjk_fallback">改</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">：</span></span></span></span> (1) $</li>
<li>两个元素的置换（换位）：
<ul>
<li>$ (1\ 2) $（交换1和2）</li>
<li>$ (1\ 3) $（交换1和3）</li>
<li>$ (2\ 3) $（交换2和3）</li>
</ul>
</li>
<li>三个元素的循环置换：
<ul>
<li>$ (1\ 2\ 3) $（1变2，2变3，3变1）</li>
<li>$ (1\ 3\ 2) $（1变3，3变2，2变1）</li>
</ul>
</li>
</ol>
<p>这些元素可以表示为置换的乘积，其中置换的乘法是按照从右到左的顺序进行的。以下是 $ S_3 $ 的所有元素：</p>
<ol>
<li>$ e = (1) $</li>
<li>$ (1\ 2) $</li>
<li>$ (1\ 3) $</li>
<li>$ (2\ 3) $</li>
<li>$ (1\ 2\ 3) $</li>
<li>$ (1\ 3\ 2) $</li>
</ol>
<p>关于交换性，$ S_3 $ 中的置换不一定是交换的。例如，置换 $ (1\ 2) $ 和 $ (1\ 3) $ 的乘积不等于它们的逆序乘积：<br>
$ (1\ 2) \cdot (1\ 3) = (1\ 2\ 3) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex">
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> (1\ 3) \cdot (1\ 2) = (1\ 3\ 2) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>因此，</mtext></mrow><annotation encoding="application/x-tex">
因此，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">此</span><span class="mord cjk_fallback">，</span></span></span></span> (1\ 2) $ 和 $ (1\ 3) $ 在 $ S_3 $ 中不交换。<br>
在 $ S_3 $ 中，只有当两个置换的循环结构不重叠时，它们才是交换的。例如，$ (1\ 2) $ 和 $ (2\ 3) $ 是交换的，因为它们的循环结构不重叠：<br>
$ (1\ 2) \cdot (2\ 3) = (2\ 3) \cdot (1\ 2) = (1\ 2\ 3) $<br>
但是，当两个置换的循环结构重叠时，它们通常不交换。</p>
<h3 id="群的同态与同构如循环群-满同态与同构"><a class="markdownIt-Anchor" href="#群的同态与同构如循环群-满同态与同构"></a> 群的同态与同构；如循环群、满同态与同构；</h3>
<p><strong>群的同态 (Group Homomorphism)</strong>：<br>
一个群同态是从一个群 $ G $ 到另一个群 $ H $ 的一个映射 $ \phi: G \rightarrow H $，它保持群的运算不变。具体来说，对于 $ G $ 中的任意元素 $ a $ 和 $ b <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，都有：</mtext></mrow><annotation encoding="application/x-tex">，都有：
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">都</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">：</span></span></span></span> \phi(a \cdot b) = \phi(a) \ast \phi(b) $<br>
其中 $ \cdot $ 是群 $ G $ 中的运算，$ \ast $ 是群 $ H $ 中的运算。群同态还必须将 $ G $ 的单位元映射到 $ H $ 的单位元，即 $ \phi(e_G) = e_H $。<br>
<strong>满同态 (Epimorphism)</strong>：<br>
一个满同态是一个群同态 $ \phi: G \rightarrow H $，它是“满”的，意味着它的像 $ \phi(G) $ 等于群 $ H <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>。换句话说，</mtext></mrow><annotation encoding="application/x-tex">。换句话说，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">换</span><span class="mord cjk_fallback">句</span><span class="mord cjk_fallback">话</span><span class="mord cjk_fallback">说</span><span class="mord cjk_fallback">，</span></span></span></span> H $ 中的每个元素都是 $ G $ 中某个元素的像。<br>
<strong>群的同构 (Group Isomorphism)</strong>：<br>
一个群同构是一个双射（即既是单射又是满射）的群同态。如果存在一个群同构 $ \phi: G \rightarrow H $，则群 $ G $ 和群 $ H $ 被认为是同构的，通常记作 $ G \cong H $。群的同构保持了群的所有结构特性，因此同构的群在结构上是相同的。<br>
<strong>循环群 (Cyclic Group)</strong>：<br>
一个循环群是一个可以由单个元素生成的群。如果 $ G $ 是一个群，且存在一个元素 $ g \in G $ 使得 $ G = \langle g \rangle = {g^n | n \in \mathbb{Z}} $，则 $ G $ 是循环群。循环群可以是无限的，也可以是有限的。无限循环群通常记作 $ \mathbb{Z} $，而有限循环群 $ \mathbb{Z}_n $ 包含 $ n $ 个元素。<br>
<strong>循环群的同态与同构</strong>：</p>
<ul>
<li>循环群的同态：如果 $ G $ 是一个循环群，由 $ g $ 生成，那么任何群同态 $ \phi: G \rightarrow H $ 都由 $ \phi(g) $ 的像唯一确定。如果 $ \phi(g) $ 在 $ H $ 中有有限的阶 $ m $，则 $ \phi $ 将 $ G $ 映射到 $ H $ 的一个有限子群。</li>
<li>循环群的满同态：如果 $ \phi: \mathbb{Z} \rightarrow H $ 是一个满同态，那么 $ H $ 必须是一个循环群。如果 $ H $ 是有限的，那么 $ \phi $ 将 $ \mathbb{Z} $ 映射到 $ \mathbb{Z}_n $。</li>
<li>循环群的同构：两个循环群 $ \mathbb{Z}_n $ 和 $ \mathbb{Z}_m $ 是同构的当且仅当 $ n = m $。同样，无限循环群 $ \mathbb{Z} $ 与任何有限循环群 $ \mathbb{Z}_n $ 不同构。<br>
例如，考虑 $ \mathbb{Z}_6 $ 和 $ \mathbb{Z}_2 \times \mathbb{Z}_3 $。这两个群是同构的，因为它们都有6个元素，并且它们的结构相同。一个可能的同构映射 $ \phi: \mathbb{Z}_6 \rightarrow \mathbb{Z}_2 \times \mathbb{Z}_3 $ 可以定义为 $ \phi(k) = (k \mod 2, k \mod 3) $。</li>
</ul>
<h3 id="环的同态如零因子-整数环-剩余类环"><a class="markdownIt-Anchor" href="#环的同态如零因子-整数环-剩余类环"></a> 环的同态；如零因子、整数环、剩余类环；</h3>
<p>环的同态类似于群的同态，但是适用于环的结构。<br>
<strong>环的同态 (Ring Homomorphism)</strong>：<br>
一个环同态是从一个环 $ R $ 到另一个环 $ S $ 的一个映射 $ f: R \rightarrow S $，它满足以下两个条件：</p>
<ol>
<li>加法保持性：对于 $ R $ 中的任意元素 $ a $ 和 $ b $，有 $ f(a + b) = f(a) + f(b) $。</li>
<li>乘法保持性：对于 $ R $ 中的任意元素 $ a $ 和 $ b $，有 $ f(a \cdot b) = f(a) \cdot f(b) $。<br>
此外，环同态通常还满足 $ f(0_R) = 0_S $，其中 $ 0_R $ 和 $ 0_S $ 分别是环 $ R $ 和 $ S $ 的加法单位元。<br>
以下是一些与环同态相关的概念：<br>
<strong>零因子 (Zero Divisor)</strong>：<br>
在环 $ R $ 中，如果存在非零元素 $ a $ 和 $ b $，使得 $ a \cdot b = 0 $，则称 $ a $ 或 $ b $ 为零因子。零因子在环中是非常重要的，因为它们的存在意味着环不是整环。<br>
<strong>整数环 (Ring of Integers)</strong>：<br>
整数环通常指的是包含所有整数 $ \mathbb{Z} $ 的环，它在加法和乘法下是封闭的，没有零因子，并且每个非零元素都有乘法逆元（除了加法单位元0）。<br>
<strong>剩余类环 (Ring of Residues)</strong>：<br>
剩余类环是基于整数模 $ n $ 形成的环，记作 $ \mathbb{Z}/n\mathbb{Z} $ 或 $ \mathbb{Z}_n $。在这个环中，元素是整数 $ 0, 1, 2, \ldots, n-1 $ 的剩余类，加法和乘法是通过模 $ n $ 运算定义的。<br>
<strong>环同态的例子</strong>：</li>
</ol>
<ul>
<li>考虑一个映射 $ f: \mathbb{Z} \rightarrow \mathbb{Z}_n $，定义为 $ f(a) = a \mod n $。这是一个环同态，因为它保持加法和乘法运算。</li>
<li>另一个例子是映射 $ g: \mathbb{Z} \rightarrow \mathbb{Z}[x] $，定义为 $ g(a) = a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>。这里，</mtext></mrow><annotation encoding="application/x-tex">。这里，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">，</span></span></span></span> \mathbb{Z}[x] $ 是多项式环，$ g $ 也是一个环同态。<br>
环同态的一个重要性质是它将零因子映射到零因子。如果 $ R $ 是一个没有零因子的环（即一个整环），那么 $ f® $ 也不会包含零因子。同样，如果 $ R $ 是一个域，那么 $ f® $ 也将是一个域。<br>
环同态还可以是单射、满射或双射。如果环同态是双射，则称两个环是同构的。同构的环在结构上是完全相同的。</li>
</ul>
<h3 id="有限域的特征以及gf2xmod-x21gf2xmodx2-1gf2xmodx21"><a class="markdownIt-Anchor" href="#有限域的特征以及gf2xmodx2-1"></a> 有限域的特征以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mspace></mspace><mspace width="0.6666666666666666em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mo stretchy="false">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mspace></mrow><annotation encoding="application/x-tex">GF(2)[x]\mod(x^2 + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h3>
<p>有限域的特征是指域中的最小正整数 $ p $，使得对于域中的所有元素 $ a $，都有 $ p \cdot a = 0 $。如果不存在这样的正整数，则称该有限域的特征为 0。</p>
<p>在有限域理论中，$ \text{GF}(2)[x] \mod (x^2 + 1) $ 表示的是在有限域 $ \text{GF}(2) $ 上的多项式环 $ \text{GF}(2)[x] $ 中，取模 $ x^2 + 1 $ 的剩余类环。</p>
<p>具体解释如下：</p>
<ol>
<li><strong>$ \text{GF}(2) $</strong>：这是有限域，也称为二元域，它包含两个元素，通常表示为 {0, 1}，且加法和乘法都是模 2 运算。</li>
<li><strong>$ \text{GF}(2)[x] $</strong>：这是在 $ \text{GF}(2) $ 上的多项式环，其系数都是来自 $ \text{GF}(2) $。这意味着多项式的系数只能是 0 或 1。</li>
<li><strong>$ x^2 + 1 $</strong>：这是一个在 $ \text{GF}(2)[x] $ 中的二次多项式。</li>
<li><strong>取模运算</strong>：当我们说 $ \text{GF}(2)[x] \mod (x^2 + 1) $，我们实际上是在考虑所有形式为 $ a_0 + a_1x + a_2x^2 + \ldots + a_nx^n $ 的多项式，其中 $ a_i \in \text{GF}(2) $，并且我们将这些多项式按照 $ x^2 + 1 $ 的余数来分类。<br>
在这个剩余类环中，由于 $ x^2 + 1 = 0 $（在 $ \text{GF}(2) $ 中，1 + 1 = 0），我们可以将 $ x^2 $ 替换为 1。因此，任何多项式都可以通过以下方式简化：</li>
</ol>
<ul>
<li>$ x^2 $ 替换为 1</li>
<li>$ x^3 $ 替换为 $ x $（因为 $ x^3 = x \cdot x^2 = x \cdot 1 = x $）</li>
<li>更高次的 $ x $ 的幂可以通过类似的方式简化。<br>
因此，$ \text{GF}(2)[x] \mod (x^2 + 1) $ 实际上是一个包含所有形式为 $ a_0 + a_1x $ 的多项式的集合，其中 $ a_0, a_1 \in \text{GF}(2) $。这个集合有以下元素：</li>
<li>$ 0 $</li>
<li>$ 1 $</li>
<li>$ x $</li>
<li>$ 1 + x $<br>
这些元素构成了一个有限域，通常记作 $ \text{GF}(4) $，因为它有 $ 2^2 = 4 $ 个元素。这个域是通过在 $ \text{GF}(2) $ 上添加一个满足 $ x^2 + 1 = 0 $ 的元素 $ x $ 来构造的。</li>
</ul>
<h3 id="复数域与实数域的区别"><a class="markdownIt-Anchor" href="#复数域与实数域的区别"></a> 复数域与实数域的区别</h3>
<ol>
<li><strong>定义</strong>：
<ul>
<li><strong>实数域</strong>（通常记为 $ \mathbb{R} $）：实数域包含所有可以在数轴上表示的数，包括有理数（如整数和分数）和无理数（如 $ \pi $ 和 $ \sqrt{2} $）。</li>
<li><strong>复数域</strong>（通常记为 $ \mathbb{C} $）：复数域是由实数和虚数单位 $ i $（满足 $ i^2 = -1 $）的线性组合构成的，形式为 $ a + bi $，其中 $ a $ 和 $ b $ 是实数。</li>
</ul>
</li>
<li><strong>结构</strong>：
<ul>
<li>实数域是实数的一个完备的有序域，这意味着它满足有序性、交换律、结合律、分配律，并且每个非空有界实数集都有最大值和最小值。</li>
<li>复数域是一个代数闭域，这意味着每个非恒等的多项式在复数域中都有根。复数域不满足有序性，因此我们不能说一个复数大于或小于另一个复数。</li>
</ul>
</li>
<li><strong>维度</strong>：
<ul>
<li>实数域是一维的，因为每个实数都可以在数轴上表示为一个点。</li>
<li>复数域是二维的，因为每个复数都可以在复平面上表示为一个点，其中实部对应水平轴（实轴），虚部对应垂直轴（虚轴）。</li>
</ul>
</li>
<li><strong>根的性质</strong>：
<ul>
<li>在实数域中，不是每个多项式都有根。例如，多项式 $ x^2 + 1 = 0 $ 在实数域中没有根。</li>
<li>在复数域中，每个非恒等的多项式都有根，这是代数基本定理的一个结果。</li>
</ul>
</li>
<li><strong>运算的封闭性</strong>：
<ul>
<li>实数域在加法、减法、乘法和除法（除数不为零）下是封闭的，但并非所有实数都有实数平方根。</li>
<li>复数域在加法、减法、乘法和除法（除数不为零）下也是封闭的，并且每个非零复数都有复数平方根。</li>
</ul>
</li>
</ol>
<p><strong>题4-23</strong> 设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo>+</mo><mi>b</mi><mi>i</mi><mi mathvariant="normal">∣</mi><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><mi>Z</mi><mo separator="true">,</mo><mi>i</mi><mo>=</mo><msqrt><mrow><mo>−</mo><mn>1</mn></mrow></msqrt><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S=\{a+bi|a,b\in Z,i=\sqrt{-1}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord">∣</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.115555em;vertical-align:-0.25em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8655550000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.825555em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17444499999999996em;"><span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，S对于复数的加法和乘法是整环，但不是域；在集合S中，任何两个元素的和和积仍然是S中的元素（封闭性），并且加法和乘法满足交换律、结合律和分配律。但是，S中并不是每个非零元素都有乘法逆元，因此它是一个整环而不是域。</p>
<h3 id="理想以及主理想的定义以及基本的性质"><a class="markdownIt-Anchor" href="#理想以及主理想的定义以及基本的性质"></a> 理想以及主理想的定义以及基本的性质</h3>
<p><strong>理想定义：</strong><br>
在一个环R中，一个非空子集I称为R的一个理想，如果对于任意的r ∈ R和任意的a ∈ I，以下两个条件成立：</p>
<ol>
<li>如果r ∈ R，a ∈ I，则r * a ∈ I（左理想）且a * r ∈ I（右理想）。如果环R是交换环，则只需要满足其中一个条件，因为乘法是交换的。</li>
<li>如果a, b ∈ I，则a - b ∈ I。</li>
</ol>
<p><strong>理想的基本性质：</strong></p>
<ol>
<li>理想包含环的零元素，因为对于任何a ∈ I，有a - a = 0 ∈ I。</li>
<li>理想对于加法是封闭的，即如果a, b ∈ I，则a + b ∈ I。</li>
<li>理想对于环R中的元素与理想内元素的乘法是封闭的。</li>
<li>理想的交集仍然是理想。</li>
<li>理想的和（即两个理想的元素的所有加法组合）仍然是理想。</li>
</ol>
<p><strong>主理想定义：</strong><br>
在环R中，由单个元素生成的理想称为主理想。具体来说，如果a ∈ R，则由a生成的理想记为(a)，定义为：<br>
(a) = {r * a | r ∈ R} = {a * r | r ∈ R}<br>
在交换环中，这两个定义是等价的，因为乘法是交换的。<br>
<strong>主理想的性质：</strong></p>
<ol>
<li>主理想是由环中的单个元素生成的最小理想。</li>
<li>在交换环中，每个元素都包含在一个主理想中。</li>
<li>主理想是交换环的一个基本构建块，因为环的理想结构可以通过主理想的组合来理解。</li>
<li>在整环（没有零因子的交换环）中，每个理想都可以表示为某个主理想的有限积。<br>
例如，在整数环Z中，由一个整数n生成的理想(n)包含所有能被n整除的整数，即(n) = {kn | k ∈ Z}。这是一个主理想，也是Z的一个理想。</li>
</ol>
<h3 id="有限循环群的生成元"><a class="markdownIt-Anchor" href="#有限循环群的生成元"></a> 有限循环群的生成元</h3>
<ol>
<li><strong>确定群的阶</strong>：首先，你需要知道群的阶（即群中元素的数量）。设群的阶为 $ n $。</li>
<li><strong>寻找可能的生成元</strong>：在 $ n $ 阶循环群中，生成元的数量等于 $ \varphi(n) $，其中 $ \varphi $ 是欧拉函数，它计算小于 $ n $ 且与 $ n $ 互质的正整数的数量。</li>
<li><strong>验证生成元</strong>：对于每个可能的生成元 $ g $，你需要验证 $ g^k \neq e $ 对于所有 $ 1 \leq k &lt; n $，其中 $ e $ 是群的单位元，且 $ g^n = e $。</li>
</ol>
<h3 id="二阶矩阵对于普通矩阵乘法构成群的例子"><a class="markdownIt-Anchor" href="#二阶矩阵对于普通矩阵乘法构成群的例子"></a> 二阶矩阵对于普通矩阵乘法构成群的例子</h3>
<p>在矩阵的乘法下构成群的一个二阶矩阵的例子是二维旋转矩阵的集合。考虑所有绕原点旋转的旋转矩阵，这些矩阵可以表示为：<br>
$ R(\theta) = \begin{bmatrix} \cos(\theta) &amp; -\sin(\theta) \ \sin(\theta) &amp; \cos(\theta) \end{bmatrix} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>其中，</mtext></mrow><annotation encoding="application/x-tex">
其中，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span></span></span></span> \theta $ 是旋转角度。如果我们限制 $ \theta $ 为 $ 0 $ 或 $ \pi <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（即只考虑</mtext><mn>0</mn><mtext>度和</mtext><mn>180</mn><mtext>度的旋转），我们得到一个包含两个元素的集合，它们在矩阵乘法下构成一个群。这两个元素是：</mtext></mrow><annotation encoding="application/x-tex">（即只考虑0度和180度的旋转），我们得到一个包含两个元素的集合，它们在矩阵乘法下构成一个群。这两个元素是：
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">只</span><span class="mord cjk_fallback">考</span><span class="mord cjk_fallback">虑</span><span class="mord">0</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">和</span><span class="mord">1</span><span class="mord">8</span><span class="mord">0</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">旋</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">含</span><span class="mord cjk_fallback">两</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">矩</span><span class="mord cjk_fallback">阵</span><span class="mord cjk_fallback">乘</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">构</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">群</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">两</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">：</span></span></span></span> R(0) = \begin{bmatrix} 1 &amp; 0 \ 0 &amp; 1 \end{bmatrix} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex">
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> R(\pi) = \begin{bmatrix} -1 &amp; 0 \ 0 &amp; -1 \end{bmatrix} $<br>
这个集合在矩阵乘法下满足群的四个性质：</p>
<ol>
<li><strong>封闭性</strong>：两个旋转矩阵的乘积仍然是一个旋转矩阵。在这个例子中，$ R(0) \cdot R(\pi) = R(\pi) \cdot R(0) = R(\pi) $。</li>
<li><strong>结合性</strong>：矩阵乘法是结合的，即 $ (R(\theta_1) \cdot R(\theta_2)) \cdot R(\theta_3) = R(\theta_1) \cdot (R(\theta_2) \cdot R(\theta_3)) $。</li>
<li><strong>单位元</strong>：$ R(0) $ 是单位元，因为对于任何旋转矩阵 $ R(\theta) $，有 $ R(0) \cdot R(\theta) = R(\theta) \cdot R(0) = R(\theta) $。</li>
<li><strong>逆元</strong>：每个旋转矩阵 $ R(\theta) $ 都有一个逆元，在这个例子中，$ R(\pi) $ 是它自己的逆元，因为 $ R(\pi) \cdot R(\pi) = R(0) $。<br>
因此，这个集合 ${ R(0), R(\pi) } $ 在矩阵乘法下构成一个群，它实际上是一个二阶循环群。</li>
</ol>
<h3 id="gf2x上的多项式分解与多项式的除法运算"><a class="markdownIt-Anchor" href="#gf2x上的多项式分解与多项式的除法运算"></a> GF(2)[x]上的多项式分解与多项式的除法运算</h3>
<p>在有限域 GF(2) 上，多项式的分解和除法运算遵循与实数域上多项式相同的规则，但是所有的系数都是在 GF(2) 中，即系数只能是 0 或 1。GF(2) 上的运算遵循模 2 的算术规则。</p>
<p>现在，让我们来看一下给定的多项式 $ x^4 + x^2 + 1 $ 在 GF(2) 上的分解。</p>
<p>首先，我们需要检查 $ x^4 + x^2 + 1 $ 是否可以被分解为更简单的多项式的乘积。在 GF(2) 上，我们只有两个可能的系数，0 和 1，所以我们的任务是比较简单的。<br>
给定的分解是 $ x^4 + x^2 + 1 = (x^2 + x + 1)^2 $。我们可以通过展开右侧的平方来验证这个等式是否成立。<br>
展开 $ (x^2 + x + 1)^2 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>：</mtext></mrow><annotation encoding="application/x-tex">：
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">：</span></span></span></span><br>
(x^2 + x + 1)^2 = (x^2 + x + 1)(x^2 + x + 1)<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex">
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span><br>
= x^4 + x^3 + x^2 + x^3 + x^2 + x + x^2 + x + 1<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex">
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span><br>
= x^4 + (x^3 + x^3) + (x^2 + x^2 + x^2) + (x + x) + 1<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>在</mtext><mi>G</mi><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mtext>中，</mtext></mrow><annotation encoding="application/x-tex">
在 GF(2) 中，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">在</span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span></span></span></span> x^3 + x^3 = 0 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（因为</mtext><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>0</mn><mtext>），</mtext></mrow><annotation encoding="application/x-tex">（因为 1 + 1 = 0），</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">为</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">，</span></span></span></span> x + x = 0 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，所以我们有：</mtext></mrow><annotation encoding="application/x-tex">，所以我们有：
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">：</span></span></span></span><br>
= x^4 + 0 + 3x^2 + 0 + 1<br>
$<br>
在 GF(2) 中，任何系数乘以 2 都是 0，所以 $ 3x^2 $ 等于 $ x^2 $（因为 $ 1 + 1 = 0 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>）：</mtext></mrow><annotation encoding="application/x-tex">）：
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">：</span></span></span></span><br>
= x^4 + x^2 + 1<br>
$<br>
因此，我们验证了 $ x^4 + x^2 + 1 = (x^2 + x + 1)^2 $ 在 GF(2) 上是成立的。这意味着 $ x^2 + x + 1 $ 是 $ x^4 + x^2 + 1 $ 在 GF(2) 上的一个不可约多项式因子。</p>
<h3 id="对于n阶元素a生成的群aieaieaie当且仅当ninvert-iniakakak的阶为mknmknmkn证明过程"><a class="markdownIt-Anchor" href="#对于n阶元素a生成的群aie当且仅当nvert-iak的阶为mkn证明过程"></a> 对于n阶元素a生成的群,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>i</mi></msup><mo>=</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">a^{i}=e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span>当且仅当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">∣</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">n\vert i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">∣</span><span class="mord mathnormal">i</span></span></span></span>;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">a^{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>的阶为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m/(k,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，证明过程</h3>
<p><strong>充分性（即若 $ n \mid i $，则 $ a^i = e $）：</strong><br>
假设 $ n \mid i $，这意味着存在某个整数 $ k $ 使得 $ i = kn <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>。因此，</mtext></mrow><annotation encoding="application/x-tex">。因此，
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">此</span><span class="mord cjk_fallback">，</span></span></span></span> a^i = a^{kn} = (a<sup>n)</sup>k. $<br>
由于 $ a $ 是 $ n $ 阶元素，我们知道 $ a^n = e $，其中 $ e $ 是群的单位元。所以，<br>
$ (a<sup>n)</sup>k = e^k = e. $<br>
这就证明了在 $ n \mid i $ 的情况下，$ a^i = e $。<br>
<strong>必要性（即若 $ a^i = e $，则 $ n \mid i $）：</strong><br>
假设 $ a^i = e $。我们要证明 $ n \mid i $。根据群的性质，任何元素的阶都是该元素的最小正幂次方使得结果为单位元。因为 $ a $ 的阶是 $ n $，我们有 $ a^n = e $。现在我们来看 $ a^i $ 和 $ a^n $ 的关系。<br>
首先，我们可以将 $ i $ 表示成 $ i = qn + r $，其中 $ q $ 和 $ r $ 是整数，并且 $ 0 \leq r &lt; n <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>。于是，</mtext></mrow><annotation encoding="application/x-tex">。于是，
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">，</span></span></span></span> a^i = a^{qn + r} = (a<sup>n)</sup>q \cdot a^r = e^q \cdot a^r = a^r. $<br>
因为我们已经知道 $ a^i = e $，所以我们有 $ a^r = e $。但是，由于 $ a $ 的阶是 $ n $，只有当 $ r = 0 $ 时，$ a^r = e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>。因此，</mtext></mrow><annotation encoding="application/x-tex">。因此，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">此</span><span class="mord cjk_fallback">，</span></span></span></span> i = qn $，这表明 $ n \mid i $。</p>
<h3 id="正规子群定义gh如何构成群群的定义其中h为正规子群"><a class="markdownIt-Anchor" href="#正规子群定义gh如何构成群群的定义其中h为正规子群"></a> 正规子群定义，G/H如何构成群(群的定义)，其中H为正规子群</h3>
<p>正规子群的定义：<br>
设 $ G $ 是一个群，$ H $ 是 $ G $ 的一个子群。如果对于 $ G $ 中的所有元素 $ g $ 和 $ H $ 中的所有元素 $ h $，都有 $ gHg^{-1} \subseteq H $，那么 $ H $ 被称为 $ G $ 的一个正规子群，记作 $ H \triangleleft G <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>。</mtext></mrow><annotation encoding="application/x-tex">。
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">。</span></span></span></span> G/H $ 如何构成群（群的定义）：<br>
设 $ H $ 是群 $ G $ 的一个正规子群，我们可以定义 $ G $ 关于 $ H $ 的商群 $ G/H $ 如下：</p>
<ol>
<li><strong>集合</strong>：$ G/H $ 是由 $ G $ 中所有左陪集 $ gH $（其中 $ g \in G $）组成的集合，即 $ G/H = { gH : g \in G } $。</li>
<li><strong>运算</strong>：定义 $ G/H $ 上的运算为 $ (gH)(g’H) = (gg’)H $，对于所有 $ g, g’ \in G $。<br>
现在我们验证 $ G/H $ 是否满足群的定义：</li>
</ol>
<ul>
<li><strong>封闭性</strong>：对于任意 $ gH, g’H \in G/H $，我们有 $ (gH)(g’H) = (gg’)H $。因为 $ gg’ \in G $，所以 $ (gg’)H \in G/H $。这表明 $ G/H $ 在定义的运算下是封闭的。</li>
<li><strong>结合性</strong>：对于任意 $ gH, g’H, hH \in G/H <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，我们有</mtext></mrow><annotation encoding="application/x-tex">，我们有
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">有</span></span></span></span> <a href="hH">(gH)(g’H)</a> = (gg’H)(hH) = (gg’h)H <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>和</mtext></mrow><annotation encoding="application/x-tex">
和
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">和</span></span></span></span> (gH)[(g’H)(hH)] = (gH)(g’hH) = (g(g’h))H = (gg’h)H. $<br>
这表明结合律在 $ G/H $ 中成立。</li>
<li><strong>单位元</strong>：$ H $ 是 $ G $ 的正规子群，所以 $ eH = H $，其中 $ e $ 是 $ G $ 的单位元。对于任意 $ gH \in G/H <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，我们有</mtext></mrow><annotation encoding="application/x-tex">，我们有
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">有</span></span></span></span> gH \cdot H = gH <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>和</mtext></mrow><annotation encoding="application/x-tex">
和
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">和</span></span></span></span> H \cdot gH = gH. $<br>
这表明 $ H $ 是 $ G/H $ 的单位元。</li>
<li><strong>逆元</strong>：对于任意 $ gH \in G/H $，因为 $ H $ 是正规子群，所以 $ gHg^{-1} \subseteq H $。这意味着存在 $ h \in H $ 使得 $ g^{-1}g = h <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>。因此，</mtext></mrow><annotation encoding="application/x-tex">。因此，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">此</span><span class="mord cjk_fallback">，</span></span></span></span> g^{-1}H $ 是 $ gH $ 的逆元，因为<br>
$ (gH)(g^{-1}H) = gg^{-1}H = eH = H <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>和</mtext></mrow><annotation encoding="application/x-tex">
和
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">和</span></span></span></span> (g^{-1}H)(gH) = g^{-1}gH = eH = H. $<br>
这表明每个元素在 $ G/H $ 中都有逆元。<br>
由于 $ G/H $ 满足群的所有性质，我们可以说 $ G/H $ 是一个群。</li>
</ul>
<h3 id="群的拉格朗日定理应用"><a class="markdownIt-Anchor" href="#群的拉格朗日定理应用"></a> 群的拉格朗日定理应用</h3>
<p>拉格朗日定理是群论中的一个基本定理，它描述了有限群与其子群阶数之间的关系。以下是拉格朗日定理的内容及其应用：<br>
<strong>拉格朗日定理内容：</strong><br>
设 $ G $ 是一个有限群，$ H $ 是 $ G $ 的一个子群。那么，$ H $ 的阶（即 $ H $ 中元素的个数）是 $ G $ 的阶的因数。用数学语言表述就是：如果 $ |G| $ 表示群 $ G $ 的阶，$ |H| $ 表示子群 $ H $ 的阶，那么 $ |G| = |H| \cdot [G:H] $，其中 $ [G:H] $ 表示子群 $ H $ 在 $ G $ 中的指数，即 $ G $ 中包含 $ H $ 的左（或右）陪集的个数。<br>
<strong>拉格朗日定理的应用：</strong></p>
<ol>
<li><strong>确定群的阶数：</strong><br>
如果我们知道一个群的所有子群的阶数，拉格朗日定理可以帮助我们确定群的阶数。群的阶数必须是它所有子群阶数的倍数。</li>
<li><strong>证明某些阶数的群不可能性：</strong><br>
如果我们知道一个群 $ G $ 的阶数，并且发现某个数不是 $ G $ 阶数的因数，那么我们可以断定 $ G $ 不可能有该数作为其子群的阶数。</li>
<li><strong>群的性质：</strong><br>
拉格朗日定理可以用来证明一些关于群的基本性质，例如，如果一个群的阶数是素数，那么这个群是循环群。</li>
<li><strong>分类小阶群：</strong><br>
对于小阶群（例如阶数为 $ p^2 $ 或 $ p^3 $ 的群，其中 $ p $ 是素数），拉格朗日定理可以帮助我们分类这些群的结构。</li>
<li><strong>陪集的数量：</strong><br>
拉格朗日定理直接给出了子群陪集的数量，即 $ [G:H] = \frac{|G|}{|H|} $。</li>
<li><strong>同态与同构：</strong><br>
拉格朗日定理在同态和同构的理论中也有应用，例如，它可以帮助证明第一同构定理，即如果 $ \phi: G \rightarrow G/H $ 是自然同态，那么 $ G/\ker(\phi) \cong \text{im}(\phi) $。</li>
<li><strong>素数阶元素：</strong><br>
如果 $ p $ 是一个素数，且 $ G $ 是一个有限群，那么 $ G $ 中阶为 $ p $ 的元素的数量是 $ p $ 的倍数。</li>
<li><strong>组合问题：</strong><br>
在某些组合问题中，拉格朗日定理可以用来计算不同排列组合的数量，特别是在涉及对称性的问题中。<br>
拉格朗日定理是群论中的一个强大工具，它不仅在理论上有着广泛的应用，而且在解决具体问题时也非常有用。</li>
</ol>
<h3 id="模p剩余类集合对于加法乘法构成域证明过程"><a class="markdownIt-Anchor" href="#模p剩余类集合对于加法乘法构成域证明过程"></a> 模p剩余类集合对于加法乘法构成域，证明过程</h3>
<p>要证明模 $ p $ 剩余类集合对于加法和乘法构成一个域，其中 $ p $ 是一个素数，我们可以按照以下步骤进行：<br>
<strong>定义：</strong><br>
首先，我们定义模 $ p $ 剩余类集合为 $ \mathbb{Z}/p\mathbb{Z} = {[0], [1], [2], \ldots, [p-1]} $，其中 $ [a] $ 表示整数 $ a $ 模 $ p $ 的剩余类。<br>
<strong>加法结构：</strong></p>
<ol>
<li>
<p><strong>封闭性：</strong> 对于任意 $ [a], [b] \in \mathbb{Z}/p\mathbb{Z} $，它们的和 $ [a] + [b] $ 也在 $ \mathbb{Z}/p\mathbb{Z} $ 中，因为 $ (a + b) \mod p $ 是 $ p $ 的一个剩余类。</p>
</li>
<li>
<p><strong>结合律：</strong> 加法在 $ \mathbb{Z}/p\mathbb{Z} $ 中是结合的，因为整数加法是结合的，模运算不改变这一性质。</p>
</li>
<li>
<p><strong>单位元：</strong> 存在一个加法单位元 $ [0] $，使得对于任意 $ [a] \in \mathbb{Z}/p\mathbb{Z} $，有 $ [a] + [0] = [a] $。</p>
</li>
<li>
<p><strong>逆元：</strong> 对于任意 $ [a] \in \mathbb{Z}/p\mathbb{Z} $，存在一个加法逆元 $ [-a] $，使得 $ [a] + [-a] = [0] $。<br>
<strong>乘法结构：</strong></p>
</li>
<li>
<p><strong>封闭性：</strong> 对于任意 $ [a], [b] \in \mathbb{Z}/p\mathbb{Z} $，它们的乘积 $ [a] \cdot [b] $ 也在 $ \mathbb{Z}/p\mathbb{Z} $ 中，因为 $ (a \cdot b) \mod p $ 是 $ p $ 的一个剩余类。</p>
</li>
<li>
<p><strong>结合律：</strong> 乘法在 $ \mathbb{Z}/p\mathbb{Z} $ 中是结合的，因为整数乘法是结合的，模运算不改变这一性质。</p>
</li>
<li>
<p><strong>单位元：</strong> 存在一个乘法单位元 $ [1] $，使得对于任意 $ [a] \in \mathbb{Z}/p\mathbb{Z} $，有 $ [a] \cdot [1] = [a] $。</p>
</li>
</ol>
<p><strong>乘法对加法的分配律：</strong><br>
乘法在 $ \mathbb{Z}/p\mathbb{Z} $ 中对加法是分配的，因为整数乘法对加法的分配律在模 $ p $ 下仍然成立。<br>
<strong>乘法逆元：</strong><br>
现在我们需要证明每个非零元素 $ [a] \in \mathbb{Z}/p\mathbb{Z} $（即 $ a \neq 0 $）都有一个乘法逆元。由于 $ p $ 是素数，根据费马小定理，对于任意整数 $ a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（</mtext></mrow><annotation encoding="application/x-tex">（</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">（</span></span></span></span> a $ 不是 $ p $ 的倍数），我们有 $ a^{p-1} \equiv 1 \mod p <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>。因此，</mtext></mrow><annotation encoding="application/x-tex">。因此，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">此</span><span class="mord cjk_fallback">，</span></span></span></span> [a]^{p-1} = [1] $，这意味着 $ [a] \cdot [a^{p-2}] = [1] <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>。所以，</mtext></mrow><annotation encoding="application/x-tex">。所以，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">，</span></span></span></span> [a^{p-2}] $ 是 $ [a] $ 的乘法逆元。<br>
由于我们已经证明了 $ \mathbb{Z}/p\mathbb{Z} $ 对于加法和乘法是封闭的，存在加法和乘法的单位元，每个元素都有加法和乘法的逆元，并且乘法对加法是分配的，我们可以得出结论，$ \mathbb{Z}/p\mathbb{Z} $ 对于加法和乘法构成一个域。</p>
<h3 id="循环群的子群是循环群证明过程"><a class="markdownIt-Anchor" href="#循环群的子群是循环群证明过程"></a> 循环群的子群是循环群，证明过程</h3>
<p>要证明循环群的子群是循环群，我们可以按照以下步骤进行：<br>
<strong>定义：</strong><br>
设 $ G $ 是一个循环群，由某个元素 $ g $ 生成，即 $ G = \langle g \rangle $。一个子群 $ H $ 是 $ G $ 的一个子集，且 $ H $ 本身也是一个群。<br>
<strong>证明：</strong></p>
<ol>
<li><strong>子群的存在：</strong> 由于 $ G $ 是由 $ g $ 生成的循环群，$ G $ 中的每个元素都可以写成 $ g $ 的某个整数幂，即 $ G = { g^n | n \in \mathbb{Z} } $。</li>
<li><strong>子群的非空性：</strong> 设 $ H $ 是 $ G $ 的一个子群，根据群的性质，子群 $ H $ 必定包含单位元 $ e $。在循环群 $ G $ 中，单位元 $ e $ 可以表示为 $ g^0 $。</li>
<li><strong>子群的生成：</strong> 由于 $ H $ 是 $ G $ 的子群，$ H $ 中的每个元素都可以写成 $ g $ 的某个整数幂。我们需要证明 $ H $ 可以由 $ g $ 的某个特定整数幂生成。</li>
<li><strong>选择最小的正整数：</strong> 在 $ H $ 中，我们可以选择一个元素 $ g^k $，其中 $ k $ 是满足 $ g^k \in H $ 的最小正整数（如果 $ H $ 包含 $ g $ 的正整数幂的话）。如果 $ H $ 只包含单位元 $ e $，那么 $ H $ 就是平凡子群，由 $ g^0 $ 生成。</li>
<li><strong>生成子群：</strong> 我们现在要证明 $ H = \langle g^k \rangle $。首先，显然 $ \langle g^k \rangle \subseteq H $，因为 $ g^k $ 的所有整数幂都在 $ H $ 中。</li>
<li><strong>证明包含关系：</strong> 接下来，我们需要证明 $ H \subseteq \langle g^k \rangle $。取 $ h \in H $，则 $ h $ 可以写成 $ g^n $ 的形式，其中 $ n $ 是某个整数。由于 $ k $ 是 $ H $ 中 $ g $ 的幂的最小正指数，我们可以使用带余除法将 $ n $ 分解为 $ n = qk + r $，其中 $ q $ 是整数，$ r $ 是 $ 0 $ 到 $ k-1 $ 之间的整数。</li>
<li><strong>利用子群性质：</strong> 因为 $ h = g^n = g^{qk + r} = (g<sup>k)</sup>q \cdot g^r $，且 $ (g<sup>k)</sup>q \in \langle g^k \rangle $，我们只需要证明 $ g^r \in \langle g^k \rangle $。如果 $ r \neq 0 $，那么 $ g^r $ 将是 $ g^k $ 的一个更小的正整数幂，这与 $ k $ 的最小性矛盾。因此，$ r $ 必须为 $ 0 $，这意味着 $ h = (g<sup>k)</sup>q \in \langle g^k \rangle $。</li>
<li><strong>结论：</strong> 因此，$ H \subseteq \langle g^k \rangle $，结合前面的包含关系，我们得到 $ H = \langle g^k \rangle $。这表明 $ H $ 是由 $ g^k $ 生成的循环群。<br>
综上所述，我们证明了循环群的子群也是循环群。</li>
</ol>
<h3 id="四元数神经网络"><a class="markdownIt-Anchor" href="#四元数神经网络"></a> 四元数神经网络</h3>
<p>四元数神经网络是一种使用四元数进行计算的神经网络。与传统的使用实数进行计算的神经网络相比，四元数神经网络具有更强的表达能力和更高的计算效率。在四元数神经网络中，可以使用可交换四元数来满足乘法运算的交换律，从而提高计算效率。此外，四元数神经网络也可以应用于知识图谱嵌入等领域。<br>
四元数卷积是一种新型的卷积操作，它将一维和二维四元数和复数作为输入和输出，以解决计算机视觉和自然语言处理中的空间和旋转不变性问题。它在传统的实值卷积运算中添加了四元数，以捕获更多的旋转不变性，同时也减少了计算量。四元数卷积的研究始于2015年，目前已经广泛应用于深度学习模型中，如图像分类，目标检测，图像分割，语音识别等。<br>
四元数神经网络在图像、语音和信号处理等现实世界任务上对实值神经网络的显著改进，使其最近受到越来越多的关注。通过减少神经参数的数量，将四元数扩展到神经架构达到了最先进的性能。这种网络在偏振合成孔径雷达奇异点补偿、口语理解、机器人控制等任务中取得了比实值神经网络更高的精度或更快的收敛速度。<br>
此外，四元数神经网络的万有逼近定理表明，使用非分开激活的修正线性单元（ReLU）型激活函数的四元数神经网络具有与实值神经网络相当的逼近能力。在某些情况下，四元数神经网络甚至表现出比实值神经网络更强的逼近能力。<br>
综上所述，四元数神经网络是一个新兴的研究领域，具有广阔的应用前景，特别是在处理具有旋转对称性的数据时表现出独特的优势。</p>
<h3 id="复值神经网络"><a class="markdownIt-Anchor" href="#复值神经网络"></a> 复值神经网络</h3>
<p>复值神经网络（Complex-Valued Neural Networks, CVNNs）是一种特殊的神经网络架构，它使用复数而不是实数来表示神经元的激活值和权重。这种复数表示方式为神经网络带来了额外的表达能力和建模灵活性，在某些应用场景中表现出色。复值神经网络的核心思想是将实数域上的神经网络扩展到复数域上。在复数域中，神经元的输入、输出和权重都是复数，这引入了新的数学运算，如复数加法、复数乘法等。这些复数运算赋予了神经网络更丰富的表达能力。<br>
复值神经网络的主要特点包括：<br>
复数表示：神经元的输入、输出和权重都是复数，而不是传统的实数。这种复数表示方式增加了神经网络的自由度和表达能力。<br>
复数运算：复值神经网络使用复数加法、复数乘法等复数运算来进行前向传播和反向传播。这些复数运算与实数运算有所不同，引入了相位和幅度的概念。<br>
复数激活函数：传统神经网络使用实数激活函数，如sigmoid、tanh等。而复值神经网络需要设计复数激活函数，如复数sigmoid、复数tanh等，以满足复数域上的需求。<br>
复数梯度计算：在训练复值神经网络时，需要计算复数权重的梯度。这需要使用复数微分法，如Cauchy-Riemann条件等，以确保梯度计算的正确性。<br>
复值神经网络在信号处理、图像处理、时间序列分析等领域表现出优势。例如，在信号处理领域，复值神经网络擅长处理复数信号，如无线通信、雷达信号等，可以同时建模信号的幅度和相位信息。在图像处理方面，复值神经网络可以更好地捕捉图像中的相位信息，对于一些相位敏感的图像处理任务，如全息图像、相干成像等，复值神经网络表现出色。在时间序列分析方面，复值神经网络可以建模时间序列数据中的周期性和相位信息，在时间序列预测、语音识别等任务上有优势。<br>
尽管复值神经网络具有这些优势，但它们也面临一些挑战，如复数激活函数的设计、复数梯度计算的复杂性、收敛性等。目前，复值神经网络仍属于前沿研究领域，在一些特定应用中展现出良好的性能，但还需要进一步的理论研究和工程实践来提高其实用性和普及度。</p>
</article></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s3.bmp.ovh/imgs/2024/10/12/ab3f0e20e95418fd.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Astronomia001</div><div class="author-info__description">各位早上中午晚上好！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%BE%A4-%E5%AD%90%E7%BE%A4%E9%99%AA%E9%9B%86%E9%99%A4%E7%8E%AF%E7%8E%AF%E5%90%8C%E6%80%81%E6%9C%AC%E5%8E%9F%E5%85%83%E7%BE%A4%E5%90%8C%E6%80%81%E5%BE%AA%E7%8E%AF%E7%BE%A4%E7%90%86%E6%83%B3%E6%95%B4%E7%8E%AF%E5%9F%9F"><span class="toc-number">1.</span> <span class="toc-text"> 定义：群、子群；陪集；除环；环同态；本原元；群同态；循环群；理想；整环；域。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0-a-b-%E4%B8%8E%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0-a-b-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.</span> <span class="toc-text"> 最小公倍数 [a, b] 与最大公因数 (a, b) 之间的关系：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E7%BE%A4"><span class="toc-number">3.</span> <span class="toc-text"> 对称群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%A4%E7%9A%84%E5%90%8C%E6%80%81%E4%B8%8E%E5%90%8C%E6%9E%84%E5%A6%82%E5%BE%AA%E7%8E%AF%E7%BE%A4-%E6%BB%A1%E5%90%8C%E6%80%81%E4%B8%8E%E5%90%8C%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text"> 群的同态与同构；如循环群、满同态与同构；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E7%9A%84%E5%90%8C%E6%80%81%E5%A6%82%E9%9B%B6%E5%9B%A0%E5%AD%90-%E6%95%B4%E6%95%B0%E7%8E%AF-%E5%89%A9%E4%BD%99%E7%B1%BB%E7%8E%AF"><span class="toc-number">5.</span> <span class="toc-text"> 环的同态；如零因子、整数环、剩余类环；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E5%9F%9F%E7%9A%84%E7%89%B9%E5%BE%81%E4%BB%A5%E5%8F%8Agf2xmod-x21gf2xmodx2-1gf2xmodx21"><span class="toc-number">6.</span> <span class="toc-text"> 有限域的特征以及GF(2)[x]mod  (x2+1)GF(2)[x]\mod(x^2 + 1)GF(2)[x]mod(x2+1)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%95%B0%E5%9F%9F%E4%B8%8E%E5%AE%9E%E6%95%B0%E5%9F%9F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text"> 复数域与实数域的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E6%83%B3%E4%BB%A5%E5%8F%8A%E4%B8%BB%E7%90%86%E6%83%B3%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">8.</span> <span class="toc-text"> 理想以及主理想的定义以及基本的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E5%BE%AA%E7%8E%AF%E7%BE%A4%E7%9A%84%E7%94%9F%E6%88%90%E5%85%83"><span class="toc-number">9.</span> <span class="toc-text"> 有限循环群的生成元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E9%98%B6%E7%9F%A9%E9%98%B5%E5%AF%B9%E4%BA%8E%E6%99%AE%E9%80%9A%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E6%9E%84%E6%88%90%E7%BE%A4%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">10.</span> <span class="toc-text"> 二阶矩阵对于普通矩阵乘法构成群的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gf2x%E4%B8%8A%E7%9A%84%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%88%86%E8%A7%A3%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">11.</span> <span class="toc-text"> GF(2)[x]上的多项式分解与多项式的除法运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8En%E9%98%B6%E5%85%83%E7%B4%A0a%E7%94%9F%E6%88%90%E7%9A%84%E7%BE%A4aieaieaie%E5%BD%93%E4%B8%94%E4%BB%85%E5%BD%93ninvert-iniakakak%E7%9A%84%E9%98%B6%E4%B8%BAmknmknmkn%E8%AF%81%E6%98%8E%E8%BF%87%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text"> 对于n阶元素a生成的群,ai&#x3D;ea^{i}&#x3D;eai&#x3D;e当且仅当n∣in\vert in∣i;aka^{k}ak的阶为m&#x2F;(k,n)m&#x2F;(k,n)m&#x2F;(k,n)，证明过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E8%A7%84%E5%AD%90%E7%BE%A4%E5%AE%9A%E4%B9%89gh%E5%A6%82%E4%BD%95%E6%9E%84%E6%88%90%E7%BE%A4%E7%BE%A4%E7%9A%84%E5%AE%9A%E4%B9%89%E5%85%B6%E4%B8%ADh%E4%B8%BA%E6%AD%A3%E8%A7%84%E5%AD%90%E7%BE%A4"><span class="toc-number">13.</span> <span class="toc-text"> 正规子群定义，G&#x2F;H如何构成群(群的定义)，其中H为正规子群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%A4%E7%9A%84%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AE%9A%E7%90%86%E5%BA%94%E7%94%A8"><span class="toc-number">14.</span> <span class="toc-text"> 群的拉格朗日定理应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1p%E5%89%A9%E4%BD%99%E7%B1%BB%E9%9B%86%E5%90%88%E5%AF%B9%E4%BA%8E%E5%8A%A0%E6%B3%95%E4%B9%98%E6%B3%95%E6%9E%84%E6%88%90%E5%9F%9F%E8%AF%81%E6%98%8E%E8%BF%87%E7%A8%8B"><span class="toc-number">15.</span> <span class="toc-text"> 模p剩余类集合对于加法乘法构成域，证明过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BE%A4%E7%9A%84%E5%AD%90%E7%BE%A4%E6%98%AF%E5%BE%AA%E7%8E%AF%E7%BE%A4%E8%AF%81%E6%98%8E%E8%BF%87%E7%A8%8B"><span class="toc-number">16.</span> <span class="toc-text"> 循环群的子群是循环群，证明过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%85%83%E6%95%B0%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">17.</span> <span class="toc-text"> 四元数神经网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%80%BC%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">18.</span> <span class="toc-text"> 复值神经网络</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/01/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" title="网络空间安全数学基础复习">网络空间安全数学基础复习</a><time datetime="2025-01-01T11:36:14.000Z" title="发表于 2025-01-01 19:36:14">2025-01-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/" title="计算机网络（更新中）">计算机网络（更新中）</a><time datetime="2024-10-02T01:29:28.000Z" title="发表于 2024-10-02 09:29:28">2024-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E8%80%83%E5%AE%8C%E5%95%A6%E4%B8%8D%E6%9B%B4%E4%BA%86%EF%BC%89/" title="计算机组成原理（考完啦不更了）">计算机组成原理（考完啦不更了）</a><time datetime="2024-10-02T01:29:10.000Z" title="发表于 2024-10-02 09:29:10">2024-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/23/KPCUP2024-WP/" title="KPCUP2024-WP">KPCUP2024-WP</a><time datetime="2024-09-23T13:53:11.000Z" title="发表于 2024-09-23 21:53:11">2024-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/23/%E5%A4%96%E7%BD%91%E6%89%93%E7%82%B9%E6%AD%A5%E9%AA%A4/" title="外网打点步骤">外网打点步骤</a><time datetime="2024-08-23T14:16:15.000Z" title="发表于 2024-08-23 22:16:15">2024-08-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Astronomia001</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>